// Type definitions for core/util

type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
type Merge<M, N> = Omit<M, Extract<keyof M, keyof N>> & N;

/**
 * Provides a convenient way to manage timed execution of functions.
 */

export declare class Job {
  constructor
  /**
   * Function to execute as the requested job.
   */(
    fn: Function
    /**
     * The number of milliseconds to wait before starting the job.
     */,
    timeout: number
  );
  /**
   * Starts the job.
   */
  start(args?: any[]): void;
  /**
   * Starts the job in  `timeout`  milliseconds
   */
  startAfter(timeout: number, args?: any[]): void;
  /**
   * Stops the job.
   */
  stop(): void;
  /**
 * Executes the job immediately, then prevents any other calls to  `throttle()`  from running
until the  `timeout`  configured at construction passes.
 */
  throttle(...args: any[]): void;
  /**
 * Executes the job immediately, then prevents any other calls to  `throttle()`  from running for
 `timeout`  milliseconds.
 */
  throttleUntil(timeout: number, args?: any[]): void;
  /**
   * Executes job when the CPU is idle.
   */
  idle(args?: any[]): void;
  /**
   * Executes job when the CPU is idle, or when the timeout is reached, whichever occurs first.
   */
  idleUntil(timeout: number, args?: any[]): void;
  /**
   * Executes job before the next repaint.
   */
  startRaf(args?: any[]): void;
  /**
   * Executes job before the next repaint after a given amount of timeout.
   */
  startRafAfter(timeout: number, args?: any[]): void;
  /**
 * Starts the job when  `promise`  resolves.
 * 
 * The job execution is tied to the resolution of the last  `Promise`  passed. Like other methods
on  `Job` , calling  `promise()`  again with a new  `Promise`  will block execution of the job
until that new  `Promise`  resolves. Any previous  `Promise` s will still resolve normally but
will not trigger job execution.
 * 
 * Unlike other methods on  `Job` ,  `promise()`  returns a  `Promise`  which is the result of calling
 `then()`  on the passed  `promise` . That  `Promise`  resolves with either the result of job
execution or  `undefined`  if  `Promise`  was superseded by a subsequent  `Promise`  passed as
described above.
 */
  promise(promise: Promise): Promise;
}

/**
 * Capitalizes a given string (not locale-aware).
 */
export function cap(str: string): string;
/**
 * Limits  `value`  to be between  `min`  and  `max` .
 *
 * If  `min`  is greater than  `max` ,  `min`  is returned.
 */
export function clamp(min: number, max: number, value: number): number;
/**
 * If  `arg`  is a function, return it. Otherwise returns a function that returns  `arg` .
 * 
 * Example:
 * ```
const returnsZero = coerceFunction(0);
const returnsArg = coerceFunction(() => 0);
```
 */
export function coerceFunction(arg: any): Function;
/**
 * If  `arg`  is array-like, return it. Otherwise returns a single element array containing  `arg` .
 * 
 * Example:
 * ```
const returnsArray = coerceArray(0); // [0]
const returnsArg = coerceArray([0]); // [0]
const returnsObjArg = coerceArray({0: 'zeroth', length: 1});
```
 */
export function coerceArray(array: any): Array<any>;
/**
 * Loosely determines if  `tag`  is a renderable component (either a string or a function).
 */
export function isRenderable(tag: any): boolean;
/**
 * Removes ARIA-related props from  `props`  and returns them in a new object.
 * 
 * Specifically, it removes the  `role`  prop and any prop prefixed with  `aria-` . This is useful when
redirecting ARIA-related props from a non-focusable root element to a focusable child element.
 */
export function extractAriaProps(props: object): object;
/**
 * Gets the current timestamp of either  `window.performance.now`  or  `Date.now`
 */
export function perfNow(): number;
/**
 * Merges two class name maps into one.
 * 
 * The resulting map will only contain the class names defined in the  `baseMap`  and will be appended
with the value from  `additiveMap`  if it exists. Further,  `allowedClassNames`  may optionally limit
which keys will be merged from  `additiveMap`  into  `baseMap` .
 * 
 * Example:
 * ```
// merges all matching class names from additiveMap1 with baseMap1
const newMap1 = mergeClassNameMaps(baseMap1, additiveMap1);

// merge only 'a' and 'b' class names from additiveMap2 with baseMap2
const newMap2 = mergeClassNameMaps(baseMap2, additiveMap2, ['a', 'b']);
```
 */
export function mergeClassNameMaps(
  baseMap: object,
  additiveMap: object,
  allowedClassNames?: string[]
): object;
/**
 * Creates a function that memoizes the result of  `fn` .
 * 
 * Note that this function is a naive implementation and only checks the first argument for
memoization.
 */
export function memoize(fn: Function): Function;
/**
 * Maps over the  `children` , discarding any  `null`  children before and after calling the callback.
 *
 * A replacement for  `React.Children.map` .
 */
export function mapAndFilterChildren(
  children: any,
  callback: Function,
  filter?: Function
): any;
/**
 * Performs shallow comparison for given objects.
 */
export function shallowEqual(a: Obejct, b: Obejct): boolean;
