"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getNavigableTarget = getNavigableTarget;
exports.getNearestTargetFromPosition = void 0;
exports.getTargetByContainer = getTargetByContainer;
exports.getTargetByDirectionFromElement = getTargetByDirectionFromElement;
exports.getTargetByDirectionFromPosition = getTargetByDirectionFromPosition;
exports.getTargetBySelector = getTargetBySelector;
exports.isFocusable = isFocusable;

var _clamp = _interopRequireDefault(require("ramda/src/clamp"));

var _last = _interopRequireDefault(require("ramda/src/last"));

var _container = require("./container");

var _navigate = _interopRequireDefault(require("./navigate"));

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function isFocusable(elem) {
  var containers = (0, _container.getContainersForNode)(elem);
  var verifySelector = true;

  for (var i = containers.length - 1; i >= 0; i--) {
    var containerId = containers[i];

    if (!(0, _container.isNavigable)(elem, containerId, verifySelector)) {
      return false;
    } // only verify selector for the first (immediate ancestor) container


    verifySelector = false;
  }

  return true;
}

function getContainersToSearch(containerId) {
  var range = [];

  var addRange = function addRange(id) {
    var config = (0, _container.getContainerConfig)(id);

    if (id && range.indexOf(id) < 0 && config && !config.selectorDisabled) {
      range.push(id);
    }
  };

  if (containerId) {
    addRange(containerId);
  } else {
    addRange((0, _container.getDefaultContainer)());
    addRange((0, _container.getLastContainer)());

    _toConsumableArray((0, _container.getAllContainerIds)()).map(addRange);
  }

  return range;
}

function getTargetByContainer(containerId, enterTo) {
  return getContainersToSearch(containerId).reduce(function (next, id) {
    return next || (0, _container.getContainerFocusTarget)(id, enterTo);
  }, null);
}

function getTargetBySelector(selector) {
  if (!selector) return null;

  if (selector.charAt(0) === '@') {
    var containerId = selector.length === 1 ? null : selector.substr(1);
    return getTargetByContainer(containerId);
  }

  var next = (0, _utils.parseSelector)(selector)[0];

  if (next) {
    if ((0, _container.isContainer)(next)) {
      return getTargetByContainer((0, _container.getContainerId)(next));
    }

    var nextContainerIds = (0, _container.getContainersForNode)(next);

    if ((0, _container.isNavigable)(next, (0, _last["default"])(nextContainerIds), true)) {
      return next;
    }
  }

  return null;
}

function isRestrictedContainer(containerId) {
  var config = (0, _container.getContainerConfig)(containerId);
  return config && (config.enterTo === 'last-focused' || config.enterTo === 'default-element');
}

function filterRects(elementRects, boundingRect) {
  if (!boundingRect) {
    return elementRects;
  } // remove elements that are outside of boundingRect, if specified


  return elementRects.filter(function (rect) {
    if ((0, _container.isContainer)(rect.element)) {
      // For containers, test intersection since they may be larger than the bounding rect
      return (0, _utils.intersects)(boundingRect, rect);
    } else {
      // For elements, use contains with the center to include mostly visible elements
      return (0, _utils.contains)(boundingRect, rect.center);
    }
  }).map(function (rect) {
    var topUpdate = rect.top < boundingRect.top;
    var bottomUpdate = rect.bottom > boundingRect.bottom;
    var leftUpdate = rect.left < boundingRect.left;
    var rightUpdate = rect.right > boundingRect.right; // if the element's rect is larger than the bounding rect, clamp it to the bounding rect and
    // recalculate the center based on the new bounds.

    if (topUpdate || bottomUpdate || leftUpdate || rightUpdate) {
      var updated = _objectSpread(_objectSpread({}, rect), {}, {
        center: _objectSpread({}, rect.center)
      });

      if (topUpdate) updated.top = boundingRect.top;
      if (bottomUpdate) updated.bottom = boundingRect.bottom;
      if (leftUpdate) updated.left = boundingRect.left;
      if (rightUpdate) updated.right = boundingRect.right;

      if (leftUpdate || rightUpdate) {
        var centerX = updated.left + (updated.right - updated.left) / 2;
        updated.center.x = updated.center.left = updated.center.right = centerX;
      }

      if (topUpdate || bottomUpdate) {
        var centerY = updated.top + (updated.bottom - updated.top) / 2;
        updated.center.y = updated.center.top = updated.center.bottom = centerY;
      }

      return updated;
    }

    return rect;
  });
}

function getContainerContainingRect(elementRects, elementRect) {
  // find candidates that are containers and *visually* contain element
  var overlapping = elementRects.filter(function (rect) {
    return (0, _container.isContainer)(rect.element) && (0, _utils.contains)(rect, elementRect);
  }); // if the next element is a container AND the current element is *visually* contained within
  // one of the candidate element, we need to ignore container `enterTo` preferences and
  // retrieve its spottable descendants and try to navigate to them.

  if (overlapping.length) {
    return overlapping[0].element.dataset.spotlightId;
  }

  return false;
}

function getOverflowContainerRect(containerId) {
  // if the target container has overflowing content, update the boundingRect to match its
  // bounds to prevent finding elements within the container's hierarchy but not visible.
  // This filter only applies when waterfalling to prevent filtering out elements that share
  // a container tree with `element`
  var nextConfig = (0, _container.getContainerConfig)(containerId);

  if (nextConfig && nextConfig.overflow) {
    return (0, _utils.getContainerRect)(containerId);
  }
}

function getTargetInContainerByDirectionFromPosition(direction, containerId, positionRect, elementContainerIds, boundingRect) {
  var elements = (0, _container.getDeepSpottableDescendants)(containerId);
  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;

  var _loop = function _loop() {
    var overlappingContainerId = getContainerContainingRect(elementRects, positionRect); // if the pointer is within a container that is a candidate element, we need to ignore container
    // `enterTo` preferences and retrieve its spottable descendants and try to navigate to them.

    if (overlappingContainerId) {
      next = getTargetInContainerByDirectionFromPosition(direction, overlappingContainerId, positionRect, elementContainerIds, boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element.dataset.spotlightId !== overlappingContainerId;
        });
        return "continue";
      } // found a target so break out and return


      return "break";
    } // try to navigate from position to one of the candidates in containerId


    next = (0, _navigate["default"])(positionRect, direction, elementRects, (0, _container.getContainerConfig)(containerId)); // if we match a container, recurse into it

    if (next && (0, _container.isContainer)(next)) {
      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary

      var lastNavigated = next;
      next = getTargetInContainerByDirectionFromPosition(direction, nextContainerId, positionRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element !== lastNavigated;
        });
        return "continue";
      }
    } // If we've met every condition and haven't explicitly retried the search via `continue`,
    // break out and return


    return "break";
  };

  while (elementRects.length > 0) {
    var _ret = _loop();

    if (_ret === "continue") continue;
    if (_ret === "break") break;
  }

  return next;
}

function getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds, boundingRect) {
  var elements = (0, _container.getDeepSpottableDescendants)(containerId); // shortcut for previous target from element if it were saved

  var previous = (0, _container.getContainerPreviousTarget)(containerId, direction, element);

  if (previous && elements.indexOf(previous) !== -1) {
    return previous;
  } // `spotlightOverflow` is a private, and likely temporary, API to allow a component within an
  // spotlight container with `overflow: true` to be treated as if it were outside of the
  // container. The result is that the candidates, `elements` are filtered by the bounds of the
  // overflow container effectively hiding those that have overflowed and are visually hidden.
  //
  // Currently only used by moonstone/Scroller.Scrollbar as a means to allow 5-way navigation to
  // escape the Scrollable from paging controls rather than focusing contents that are out of view


  if (element.dataset.spotlightOverflow === 'ignore') {
    boundingRect = getOverflowContainerRect(containerId) || boundingRect;
  }

  var elementRects = filterRects((0, _utils.getRects)(elements), boundingRect);
  var next = null;

  var _loop2 = function _loop2() {
    var overlappingContainerId = getContainerContainingRect(elementRects, elementRect); // if the next element is a container AND the current element is *visually* contained within
    // one of the candidate elements, we need to ignore container `enterTo` preferences and
    // retrieve its spottable descendants and try to navigate to them.

    if (overlappingContainerId) {
      next = getTargetInContainerByDirectionFromElement(direction, overlappingContainerId, element, elementRect, elementContainerIds, boundingRect);

      if (!next) {
        // filter out the container and try again
        elementRects = elementRects.filter(function (rect) {
          return rect.element.dataset.spotlightId !== overlappingContainerId;
        });
        return "continue";
      } // found a target so break out and return


      return "break";
    } // If one of the downstream containers is configured for partition, we use that
    // container's bounds as the partition rect for navigation.


    var partitionContainer = elementContainerIds.slice(elementContainerIds.indexOf(containerId) + 1).find(function (id) {
      var cfg = (0, _container.getContainerConfig)(id);
      return cfg && cfg.partition;
    });
    var partitionRect = elementRect;

    if (partitionContainer) {
      partitionRect = (0, _utils.getContainerRect)(partitionContainer);
    } // try to navigate from element to one of the candidates in containerId


    next = (0, _navigate["default"])(elementRect, direction, elementRects, (0, _container.getContainerConfig)(containerId), partitionRect); // if we match a container,

    if (next && (0, _container.isContainer)(next)) {
      var nextContainerId = next.dataset.spotlightId; // need to cache this reference so we can filter it out later if necessary

      var lastNavigated = next; // and it is restricted, return its target

      if (isRestrictedContainer(nextContainerId)) {
        next = getTargetByContainer(nextContainerId);
      } else {
        // otherwise, recurse into it
        next = getTargetInContainerByDirectionFromElement(direction, nextContainerId, element, elementRect, elementContainerIds, getOverflowContainerRect(nextContainerId) || boundingRect);
      }

      if (!next) {
        elementRects = elementRects.filter(function (rect) {
          return rect.element !== lastNavigated;
        });
        return "continue";
      }
    } // If we've met every condition and haven't explicitly retried the search via `continue`,
    // break out and return


    return "break";
  };

  while (elementRects.length > 0) {
    var _ret2 = _loop2();

    if (_ret2 === "continue") continue;
    if (_ret2 === "break") break;
  }

  return next;
}

function getTargetByDirectionFromElement(direction, element) {
  var extSelector = element.getAttribute('data-spot-' + direction);

  if (typeof extSelector === 'string') {
    return getTargetBySelector(extSelector);
  }

  var elementRect = (0, _utils.getRect)(element);
  var next = (0, _container.getNavigableContainersForNode)(element).reduceRight(function (result, containerId, index, elementContainerIds) {
    result = result || getTargetInContainerByDirectionFromElement(direction, containerId, element, elementRect, elementContainerIds);

    if (!result) {
      result = getLeaveForTarget(containerId, direction); // To support a `leaveFor` configuration with navigation disallowed in the current
      // `direction`, we return the current element to prevent further searches for a
      // target in this reduction.

      if (result === false) {
        result = element;
      }
    }

    return result;
  }, null); // if the reduce above returns the original element, it means it hit a `leaveFor` config that
  // prevents navigation so we enforce that here by returning null.

  return next !== element ? next : null;
}

function getTargetByDirectionFromPosition(direction, position, containerId) {
  var pointerRect = (0, _utils.getPointRect)(position);
  return (0, _container.getNavigableContainersForNode)((0, _container.getContainerNode)(containerId)).reduceRight(function (result, id, index, elementContainerIds) {
    return result || getTargetInContainerByDirectionFromPosition(direction, id, pointerRect, elementContainerIds);
  }, null);
}
/**
 * Returns the target identified by the selector configured for the container identified by
 * `containerId` for the given `direction`. If the selector is an empty string, the method returns
 * `false` indicating that navigation isn't allowed out of the container in that direction.
 *
 * @param   {String}        containerId  Identifier for a container
 * @param   {String}        direction    Direction to navigate (up, down, left, right)
 *
 * @returns {Node|Boolean}               Target, if found, or `false` if navigation is disallowed
 * @private
 */


function getLeaveForTarget(containerId, direction) {
  var config = (0, _container.getContainerConfig)(containerId);

  if (config) {
    var target = config.restrict !== 'self-only' && config.leaveFor && config.leaveFor[direction];

    if (typeof target === 'string') {
      if (target === '') {
        return false;
      }

      return getTargetBySelector(target);
    }

    var nextContainerIds = (0, _container.getContainersForNode)(target);

    if ((0, _container.isNavigable)(target, (0, _last["default"])(nextContainerIds))) {
      return target;
    }
  }

  return null;
}

function getNavigableTarget(target) {
  if (target === document) return null;
  var parent;

  while (target && ((0, _container.isContainer)(target) || !isFocusable(target))) {
    parent = target.parentNode;
    target = parent === document ? null : parent; // calling isNavigable on document is problematic
  }

  return target;
}

var getOffsetDistanceToTargetFromPosition = function getOffsetDistanceToTargetFromPosition(distance, direction, _ref, _ref2) {
  var x = _ref.x,
      y = _ref.y;
  var left = _ref2.left,
      right = _ref2.right,
      top = _ref2.top,
      bottom = _ref2.bottom;

  if (direction === 'left' || direction === 'right') {
    if (y > bottom) {
      distance += y - bottom;
    } else if (y < top) {
      distance += top - y;
    }
  } else if (x > right) {
    distance += x - right;
  } else if (x < left) {
    distance += left - x;
  }

  return distance;
};

var getDistanceToTargetFromPosition = function getDistanceToTargetFromPosition(direction, position, elementRect) {
  var x = position.x,
      y = position.y;
  var distance;

  if (direction === 'left') {
    distance = x - elementRect.right;
  } else if (direction === 'right') {
    distance = elementRect.left - x;
  } else if (direction === 'up') {
    distance = y - elementRect.bottom;
  } else if (direction === 'down') {
    distance = elementRect.top - y;
  }

  return getOffsetDistanceToTargetFromPosition((0, _clamp["default"])(0, Math.abs(distance), distance), direction, position, elementRect);
};

var getNearestTargetsInContainerFromPosition = function getNearestTargetsInContainerFromPosition(position, containerId) {
  return ['up', 'left', 'right', 'down'].reduce(function (result, direction) {
    var target = getTargetByDirectionFromPosition(direction, position, containerId);

    if (target) {
      result.push({
        direction: direction,
        target: target
      });
    }

    return result;
  }, []);
};

var getNearestTargetInContainerFromPosition = function getNearestTargetInContainerFromPosition(position, containerId) {
  var targets = getNearestTargetsInContainerFromPosition(position, containerId);

  if (!targets.length) {
    return;
  }

  targets.forEach(function (item) {
    var direction = item.direction,
        target = item.target;
    item.distance = getDistanceToTargetFromPosition(direction, position, (0, _utils.getRect)(target));
  });
  targets.sort(function (a, b) {
    return a.distance - b.distance;
  });
  return targets[0].target;
};

var getNearestTargetFromPosition = function getNearestTargetFromPosition(position, containerId) {
  return getNavigableTarget(document.elementFromPoint(position.x, position.y)) || getNearestTargetInContainerFromPosition(position, containerId);
};

exports.getNearestTargetFromPosition = getNearestTargetFromPosition;