"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = exports.FloatingLayerBase = exports.FloatingLayer = void 0;

var _dispatcher = require("@enact/core/dispatcher");

var _handle = require("@enact/core/handle");

var _classnames = _interopRequireDefault(require("classnames"));

var _invariant = _interopRequireDefault(require("invariant"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = require("react");

var _reactDom = _interopRequireDefault(require("react-dom"));

var _Cancelable = _interopRequireDefault(require("../Cancelable"));

var _FloatingLayerDecorator = require("./FloatingLayerDecorator");

var _Scrim = _interopRequireDefault(require("./Scrim"));

var _FloatingLayerModule = _interopRequireDefault(require("./FloatingLayer.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["children", "className", "floatLayerClassName", "open", "scrimType"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

/**
 * A component that creates an entry point to the new render tree.
 *
 * This is used for modal components such as popups.
 *
 * @class FloatingLayerBase
 * @memberof ui/FloatingLayer
 * @ui
 * @public
 */
var FloatingLayerBase = /*#__PURE__*/function (_Component) {
  _inherits(FloatingLayerBase, _Component);

  var _super = _createSuper(FloatingLayerBase);

  function FloatingLayerBase(props) {
    var _this;

    _classCallCheck(this, FloatingLayerBase);

    _this = _super.call(this, props);
    _this.handleNotify = (0, _handle.oneOf)([(0, _handle.forEventProp)('action', 'close'), (0, _handle.call)('handleClose')], [(0, _handle.forEventProp)('action', 'mount'), (0, _handle.call)('setFloatingLayer')]).bind(_assertThisInitialized(_this));
    _this.handleClose = (0, _handle.handle)((0, _handle.forProp)('open', true), (0, _handle.forwardCustom)('onDismiss')).bind(_assertThisInitialized(_this));
    _this.handleClick = (0, _handle.handle)((0, _handle.forProp)('noAutoDismiss', false), (0, _handle.forProp)('open', true), (0, _handle.forwardCustom)('onDismiss', function () {
      return {
        detail: {
          inputType: 'click'
        }
      };
    })).bind(_assertThisInitialized(_this));

    _this.handleScroll = function (ev) {
      var currentTarget = ev.currentTarget;
      currentTarget.scrollTop = 0;
      currentTarget.scrollLeft = 0;
    };

    _this.stopPropagation = function (ev) {
      ev.nativeEvent.stopImmediatePropagation();

      if (_this.props.children.props.onClick) {
        _this.props.children.props.onClick();
      }
    };

    _this.node = null;
    _this.state = {
      readyToRender: false
    };
    return _this;
  }

  _createClass(FloatingLayerBase, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      // Must register first in order to obtain the floating layer node reference before tryinging
      // to render into it
      if (this.context && typeof this.context === 'function') {
        this.controller = this.context(this.handleNotify.bind(this));
      }

      if (this.props.scrimType === 'none' && this.props.open) {
        (0, _dispatcher.on)('click', this.handleClick);
      }
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      var _this$props = this.props,
          open = _this$props.open,
          scrimType = _this$props.scrimType;

      if (prevProps.open && !open) {
        // when open changes to false, forward close
        (0, _handle.forwardCustom)('onClose')(null, this.props);
      } else if (!prevProps.open && open && !this.state.readyToRender) {
        // when open changes to true and node hasn't rendered, render it
        this.readyToRender();
      } else if (this.state.readyToRender && (!prevState.readyToRender || prevState.readyToRender && open && !prevProps.open)) {
        // when node has been rendered and either it was just rendered in this update cycle or
        // the open prop changed in this cycle, forward open
        (0, _handle.forwardCustom)('onOpen')(null, this.props);
      }

      if (scrimType === 'none') {
        if (!prevProps.open && open) {
          (0, _dispatcher.on)('click', this.handleClick);
        } else if (prevProps.open && !open) {
          (0, _dispatcher.off)('click', this.handleClick);
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.floatingLayer) {
        (0, _dispatcher.off)('scroll', this.handleScroll, this.floatingLayer);
        this.floatingLayer = null;
      }

      (0, _dispatcher.off)('click', this.handleClick);

      if (this.controller) {
        this.controller.unregister();
      }
    }
  }, {
    key: "setFloatingLayer",
    value: function setFloatingLayer(_ref) {
      var floatingLayer = _ref.floatingLayer;
      var isNewLayer = !this.floatingLayer && floatingLayer;
      this.floatingLayer = floatingLayer; // the first time we have a valid floating layer container and this instance is set to open,
      // we need to render the layer.

      if (isNewLayer && this.props.open && !this.state.readyToRender) {
        this.readyToRender();
      }
    }
  }, {
    key: "readyToRender",
    value: function readyToRender() {
      if (this.state.readyToRender) return;
      !this.floatingLayer ? process.env.NODE_ENV !== "production" ? (0, _invariant["default"])(false, 'FloatingLayer cannot be used outside the subtree of a FloatingLayerDecorator') : (0, _invariant["default"])(false) : void 0;
      (0, _dispatcher.on)('scroll', this.handleScroll, this.floatingLayer);
      this.setState({
        readyToRender: true
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props,
          children = _this$props2.children,
          className = _this$props2.className,
          floatLayerClassName = _this$props2.floatLayerClassName,
          open = _this$props2.open,
          scrimType = _this$props2.scrimType,
          rest = _objectWithoutProperties(_this$props2, _excluded);

      var mergedClassName = (0, _classnames["default"])(floatLayerClassName, _FloatingLayerModule["default"].floatingLayer, className);
      delete rest.floatLayerId;
      delete rest.noAutoDismiss;
      delete rest.onClose;
      delete rest.onDismiss;
      delete rest.onOpen;

      if (open && this.state.readyToRender) {
        return /*#__PURE__*/_reactDom["default"].createPortal( /*#__PURE__*/(0, _jsxRuntime.jsxs)("div", _objectSpread(_objectSpread({
          className: mergedClassName
        }, rest), {}, {
          children: [scrimType !== 'none' ? /*#__PURE__*/(0, _jsxRuntime.jsx)(_Scrim["default"], {
            type: scrimType,
            onClick: this.handleClick
          }) : null, /*#__PURE__*/(0, _react.cloneElement)(children, {
            onClick: this.stopPropagation
          })]
        })), this.floatingLayer);
      }

      return null;
    }
  }]);

  return FloatingLayerBase;
}(_react.Component);

exports.FloatingLayerBase = FloatingLayerBase;
FloatingLayerBase.displayName = 'FloatingLayer';
FloatingLayerBase.propTypes =
/** @lends ui/FloatingLayer.FloatingLayerBase.prototype */
{
  /**
   * CSS classes for FloatingLayer.
   *
   * @type {String}
   * @default 'enact-fit enact-clip enact-untouchable'
   * @public
   */
  floatLayerClassName: _propTypes["default"].string,

  /**
   * Element id for floating layer.
   *
   * @type {String}
   * @default 'floatLayer'
   * @public
   */
  floatLayerId: _propTypes["default"].string,

  /**
   * Prevents FloatingLayer from hiding when the user presses cancel/back (e.g. `ESC`) key or
   * clicks outside the floating layer.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  noAutoDismiss: _propTypes["default"].bool,

  /**
   * Called when floating layer is closed.
   *
   * @type {Function}
   * @public
   */
  onClose: _propTypes["default"].func,

  /**
   * Called when a closing action is invoked.
   *
   * These actions may include pressing cancel/back (e.g. `ESC`) key or programmatically closing
   * by `FloatingLayerDecorator`. When cancel key is pressed, the function will only invoke if
   * `noAutoDismiss` is set to `false`.
   *
   * When pressing `ESC` key, event payload carries `detail` property containing `inputType`
   * value of `'key'`.
   * When clicking outside the boundary of the popup, event payload carries `detail` property
   * containing `inputType` value of `'click'`.
   *
   * @type {Function}
   * @public
   */
  onDismiss: _propTypes["default"].func,

  /**
   * Called when floating layer is opened. It will only be invoked for the first render.
   *
   * @type {Function}
   * @public
   */
  onOpen: _propTypes["default"].func,

  /**
   * Renders the floating layer and its components.
   *
   * @type {Boolean}
   * @default false
   * @public
   */
  open: _propTypes["default"].bool,

  /**
   * The scrim type that overlays FloatingLayer.
   *
   * It can be either `'transparent'`, `'translucent'`, or `'none'`.
   *
   * @type {String}
   * @default 'translucent'
   * @public
   */
  scrimType: _propTypes["default"].oneOf(['transparent', 'translucent', 'none'])
};
FloatingLayerBase.contextType = _FloatingLayerDecorator.FloatingLayerContext;
FloatingLayerBase.defaultProps = {
  floatLayerClassName: 'enact-fit enact-clip enact-untouchable',
  floatLayerId: 'floatLayer',
  noAutoDismiss: false,
  open: false,
  scrimType: 'translucent'
};
var handleCancel = (0, _handle.handle)( // can't use forProp safely since either could be undefined ~= false
function (ev, _ref2) {
  var open = _ref2.open,
      noAutoDismiss = _ref2.noAutoDismiss,
      onDismiss = _ref2.onDismiss;
  return open && !noAutoDismiss && onDismiss;
}, (0, _handle.forwardCustom)('onDismiss', function () {
  return {
    detail: {
      inputType: 'key'
    }
  };
}), _handle.stop);
/**
 * FloatingLayer that mixes {@link ui/Cancelable.Cancelable} to handle FloatingLayer dismissal.
 *
 * This is used for modal components such as popups.
 *
 * @class FloatingLayer
 * @memberof ui/FloatingLayer
 * @ui
 * @extends ui/FloatingLayer.FloatingLayerBase
 * @mixes ui/Cancelable.Cancelable
 * @public
 */

var FloatingLayer = (0, _Cancelable["default"])({
  modal: true,
  onCancel: handleCancel
}, FloatingLayerBase);
exports.FloatingLayer = FloatingLayer;
var _default = FloatingLayer;
exports["default"] = _default;