"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useEventWheel = exports.useEventVoice = exports.useEventTouch = exports.useEventMouse = exports.useEventMonitor = exports.useEventKey = exports.useEventFocus = void 0;

var _handle = require("@enact/core/handle");

var _platform = _interopRequireDefault(require("@enact/core/platform"));

var _snapshot = require("@enact/core/snapshot");

var _util = require("@enact/core/util");

var _spotlight = _interopRequireWildcard(require("@enact/spotlight"));

var _utils = require("@enact/spotlight/src/utils");

var _target = require("@enact/spotlight/src/target");

var _useScroll = require("@enact/ui/useScroll");

var _utilEvent = _interopRequireDefault(require("@enact/ui/useScroll/utilEvent"));

var _utilDOM = _interopRequireDefault(require("@enact/ui/useScroll/utilDOM"));

var _react = require("react");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

var animationDuration = _useScroll.constants.animationDuration,
    epsilon = _useScroll.constants.epsilon,
    isPageDown = _useScroll.constants.isPageDown,
    isPageUp = _useScroll.constants.isPageUp,
    overscrollTypeOnce = _useScroll.constants.overscrollTypeOnce,
    paginationPageMultiplier = _useScroll.constants.paginationPageMultiplier,
    scrollWheelPageMultiplierForMaxPixel = _useScroll.constants.scrollWheelPageMultiplierForMaxPixel;
var lastPointer = {
  x: 0,
  y: 0
};

var useEventFocus = function useEventFocus(props, instances) {
  var scrollMode = props.scrollMode;
  var scrollContainerHandle = instances.scrollContainerHandle,
      scrollContainerRef = instances.scrollContainerRef,
      scrollContentRef = instances.scrollContentRef,
      spottable = instances.spottable,
      themeScrollContentHandle = instances.themeScrollContentHandle; // Functions

  var startScrollOnFocus = function startScrollOnFocus(pos) {
    if (pos) {
      var top = pos.top,
          left = pos.left,
          bounds = scrollContainerHandle.current.getScrollBounds();

      if (scrollMode === 'translate') {
        var scrollHorizontally = bounds.maxLeft > 0 && left !== scrollContainerHandle.current.scrollLeft,
            scrollVertically = bounds.maxTop > 0 && top !== scrollContainerHandle.current.scrollTop;

        if (scrollHorizontally || scrollVertically) {
          scrollContainerHandle.current.start({
            targetX: left,
            targetY: top,
            animate: animationDuration > 0 && spottable.current.animateOnFocus,
            overscrollEffect: props.overscrollEffectOn[scrollContainerHandle.current.lastInputType] && (!themeScrollContentHandle.current.shouldPreventOverscrollEffect || !themeScrollContentHandle.current.shouldPreventOverscrollEffect())
          });
          spottable.current.lastScrollPositionOnFocus = pos;
        }
      } else {
        var _scrollHorizontally = bounds.maxLeft > 0 && Math.abs(left - scrollContainerHandle.current.scrollLeft) > epsilon,
            _scrollVertically = bounds.maxTop > 0 && Math.abs(top - scrollContainerHandle.current.scrollTop) > epsilon;

        if (_scrollHorizontally || _scrollVertically) {
          scrollContainerHandle.current.start({
            targetX: left,
            targetY: top,
            animate: spottable.current.animateOnFocus,
            overscrollEffect: props.overscrollEffectOn[scrollContainerHandle.current.lastInputType] && (!themeScrollContentHandle.current.shouldPreventOverscrollEffect || !themeScrollContentHandle.current.shouldPreventOverscrollEffect())
          });
          spottable.current.lastScrollPositionOnFocus = pos;
        }
      }
    }
  };

  function calculateAndScrollTo() {
    var positionFn = themeScrollContentHandle.current.calculatePositionOnFocus,
        scrollContentNode = scrollContentRef.current,
        spotItem = _spotlight["default"].getCurrent();

    if (spotItem && positionFn && _utilDOM["default"].containsDangerously(scrollContentNode, spotItem)) {
      var lastPos = spottable.current.lastScrollPositionOnFocus;
      var pos; // If scroll animation is ongoing, we need to pass last target position to
      // determine correct scroll position.

      if (lastPos & (scrollMode === 'translate' && scrollContainerHandle.current.animator.isAnimating() || scrollMode === 'native' && scrollContainerHandle.current.scrolling)) {
        var contentRect = (0, _utils.getRect)(scrollContentNode),
            itemRect = (0, _utils.getRect)(spotItem);
        var scrollPosition;

        if (props.direction === 'horizontal' || props.direction === 'both' && !(itemRect.left >= contentRect.left && itemRect.right <= contentRect.right)) {
          scrollPosition = lastPos.left;
        } else if (props.direction === 'vertical' || props.direction === 'both' && !(itemRect.top >= contentRect.top && itemRect.bottom <= contentRect.bottom)) {
          scrollPosition = lastPos.top;
        }

        pos = positionFn({
          item: spotItem,
          scrollPosition: scrollPosition
        });
      } else {
        pos = positionFn({
          item: spotItem
        });
      }

      if (pos && (pos.left !== scrollContainerHandle.current.scrollLeft || pos.top !== scrollContainerHandle.current.scrollTop)) {
        startScrollOnFocus(pos);
      } // update `scrollHeight`


      scrollContainerHandle.current.bounds.scrollHeight = scrollContainerHandle.current.getScrollBounds().scrollHeight;
    }
  }

  function handleFocus(ev) {
    var shouldPreventScrollByFocus = themeScrollContentHandle.current.shouldPreventScrollByFocus ? themeScrollContentHandle.current.shouldPreventScrollByFocus() : false;

    if (spottable.current.isWheeling) {
      scrollContainerHandle.current.stop();

      if (scrollMode === 'translate') {
        spottable.current.animateOnFocus = false;
      }
    }

    if (!(shouldPreventScrollByFocus || _spotlight["default"].getPointerMode() || scrollContainerHandle.current.isDragging || spottable.current.indexToFocus)) {
      var item = ev.target,
          spotItem = _spotlight["default"].getCurrent();

      if (item && item === spotItem) {
        calculateAndScrollTo();
      }
    } else if (themeScrollContentHandle.current.setLastFocusedNode) {
      themeScrollContentHandle.current.setLastFocusedNode(ev.target);
    }
  }

  function hasFocus() {
    var current = _spotlight["default"].getCurrent();

    if (current && scrollContainerRef.current) {
      return _utilDOM["default"].containsDangerously(scrollContainerRef, current);
    }
  } // Return


  return {
    calculateAndScrollTo: calculateAndScrollTo,
    handleFocus: handleFocus,
    hasFocus: hasFocus
  };
};

exports.useEventFocus = useEventFocus;

var useEventKey = function useEventKey(props, instances, context) {
  var scrollMode = props.scrollMode;
  var themeScrollContentHandle = instances.themeScrollContentHandle,
      spottable = instances.spottable,
      scrollContentRef = instances.scrollContentRef,
      scrollContainerHandle = instances.scrollContainerHandle;
  var checkAndApplyOverscrollEffectByDirection = context.checkAndApplyOverscrollEffectByDirection,
      hasFocus = context.hasFocus,
      isContent = context.isContent; // Functions

  function handleKeyDown(ev) {
    var keyCode = ev.keyCode,
        repeat = ev.repeat,
        target = ev.target;
    (0, _handle.forward)('onKeyDown', ev, props);

    if (isPageUp(keyCode) || isPageDown(keyCode)) {
      ev.preventDefault();
    }

    spottable.current.animateOnFocus = true;

    if (!repeat && hasFocus()) {
      var direction = null;

      if (isPageUp(keyCode) || isPageDown(keyCode)) {
        if (props.direction === 'vertical' || props.direction === 'both') {
          direction = isPageUp(keyCode) ? 'up' : 'down';

          if (isContent(target)) {
            ev.stopPropagation();
            scrollByPage(direction);
          }

          if (props.overscrollEffectOn.pageKey) {
            checkAndApplyOverscrollEffectByDirection(direction);
          }
        }
      } else if ((0, _spotlight.getDirection)(keyCode) && (scrollMode === 'translate' || scrollMode === 'native' && !_spotlight["default"].getPointerMode())) {
        var element = _spotlight["default"].getCurrent();

        scrollContainerHandle.current.lastInputType = 'arrowKey';
        direction = (0, _spotlight.getDirection)(keyCode);

        if (props.overscrollEffectOn.arrowKey && !(element ? (0, _target.getTargetByDirectionFromElement)(direction, element) : null)) {
          checkAndApplyOverscrollEffectByDirection(direction);
        }
      }
    }
  }

  function scrollByPage(pageKeyDirection) {
    var scrollTop = scrollContainerHandle.current.scrollTop,
        focusedItem = _spotlight["default"].getCurrent(),
        bounds = scrollContainerHandle.current.getScrollBounds(),
        isUp = pageKeyDirection === 'up',
        directionFactor = isUp ? -1 : 1,
        pageDistance = directionFactor * bounds.clientHeight * paginationPageMultiplier;

    var direction = pageKeyDirection;
    var scrollPossible = false;

    if (scrollMode === 'translate') {
      scrollPossible = isUp ? scrollTop > 0 : bounds.maxTop > scrollTop;
    } else {
      scrollPossible = isUp ? scrollTop > 0 : bounds.maxTop - scrollTop > epsilon;
    }

    scrollContainerHandle.current.lastInputType = 'pageKey';

    if (directionFactor !== scrollContainerHandle.current.wheelDirection) {
      scrollContainerHandle.current.isScrollAnimationTargetAccumulated = false;
      scrollContainerHandle.current.wheelDirection = directionFactor;
    }

    if (scrollPossible) {
      if (focusedItem) {
        var contentNode = scrollContentRef.current; // Should do nothing when focusedItem is paging control button of Scrollbar

        if (_utilDOM["default"].containsDangerously(contentNode, focusedItem)) {
          var contentRect = contentNode.getBoundingClientRect(),
              clientRect = focusedItem.getBoundingClientRect(),
              yAdjust = isUp ? 1 : -1,
              x = (0, _util.clamp)(contentRect.left, contentRect.right, (clientRect.right + clientRect.left) / 2);
          var y = 0;

          if (bounds.maxTop - epsilon < scrollTop + pageDistance || epsilon > scrollTop + pageDistance) {
            y = contentRect[isUp ? 'top' : 'bottom'] + yAdjust;
            direction = isUp ? 'down' : 'up'; // Change direction to find target in the content
          } else {
            y = (0, _util.clamp)(contentRect.top, contentRect.bottom, (clientRect.bottom + clientRect.top) / 2);
          }

          focusedItem.blur();

          if (!props['data-spotlight-container-disabled']) {
            themeScrollContentHandle.current.setContainerDisabled(true);
          }

          if (themeScrollContentHandle.current.pauseSpotlight) {
            themeScrollContentHandle.current.pauseSpotlight(true);
          }

          spottable.current.pointToFocus = {
            direction: direction,
            x: x,
            y: y
          };
        }
      } else {
        spottable.current.pointToFocus = {
          direction: direction,
          x: lastPointer.x,
          y: lastPointer.y
        };
      }

      scrollContainerHandle.current.scrollToAccumulatedTarget(pageDistance, true, props.overscrollEffectOn.pageKey);
    }
  }

  function scrollByPageOnPointerMode(ev) {
    var keyCode = ev.keyCode,
        repeat = ev.repeat;
    (0, _handle.forward)('onKeyDown', ev, props);
    ev.preventDefault();
    spottable.current.animateOnFocus = true;

    if (!repeat && (props.direction === 'vertical' || props.direction === 'both')) {
      var direction = isPageUp(keyCode) ? 'up' : 'down';
      scrollByPage(direction);

      if (props.overscrollEffectOn.pageKey) {
        /* if the spotlight focus will not move */
        checkAndApplyOverscrollEffectByDirection(direction);
      }

      return true; // means consumed
    }

    return false; // means to be propagated
  } // Return


  return {
    handleKeyDown: handleKeyDown,
    lastPointer: lastPointer,
    scrollByPageOnPointerMode: scrollByPageOnPointerMode
  };
};
/*
 * Track the last position of the pointer to check if a list should scroll by
 * page up/down keys when the pointer is on a list without any focused node.
 * `keydown` event does not occur if there is no focus on the node and
 * its descendants, we add `keydown` handler to `document` also.
 */


exports.useEventKey = useEventKey;
var scrollers = new Map(); // An app could have lists and/or scrollers more than one,
// so we should test all of them when page up/down key is pressed.

var pointerTracker = function pointerTracker(ev) {
  lastPointer.x = ev.clientX;
  lastPointer.y = ev.clientY;
};

var pageKeyHandler = function pageKeyHandler(ev) {
  var keyCode = ev.keyCode;

  if (_spotlight["default"].getPointerMode() && !_spotlight["default"].getCurrent() && (isPageUp(keyCode) || isPageDown(keyCode))) {
    var _lastPointer = lastPointer,
        x = _lastPointer.x,
        y = _lastPointer.y,
        elem = document.elementFromPoint(x, y);

    if (elem) {
      var _iterator = _createForOfIteratorHelper(scrollers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          if (_utilDOM["default"].containsDangerously(value, elem)) {
            /* To handle page keys in nested scrollable components,
             * break the loop only when `scrollByPageOnPointerMode` returns `true`.
             * This approach assumes that an inner scrollable component is
             * mounted earlier than an outer scrollable component.
             */
            if (key.scrollByPageOnPointerMode(ev)) {
              break;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }
};

var useEventMonitor = function useEventMonitor(props, instances, context) {
  var scrollContainerRef = instances.scrollContainerRef;
  var lastPointerProp = context.lastPointer,
      scrollByPageOnPointerMode = context.scrollByPageOnPointerMode; // Mutable value

  var mutableRef = (0, _react.useRef)({
    pageKeyHandlerObj: {
      scrollByPageOnPointerMode: scrollByPageOnPointerMode
    }
  });
  lastPointer = lastPointerProp; // Hooks

  (0, _react.useEffect)(function () {
    var setMonitorEventTarget = function setMonitorEventTarget(target) {
      scrollers.set(mutableRef.current.pageKeyHandlerObj, target);
    };

    var deleteMonitorEventTarget = function deleteMonitorEventTarget() {
      scrollers["delete"](mutableRef.current.pageKeyHandlerObj);
    };

    setMonitorEventTarget(scrollContainerRef.current);
    return function () {
      // TODO: Replace `this` to something.
      deleteMonitorEventTarget();
    };
  }, [scrollContainerRef]);
};

exports.useEventMonitor = useEventMonitor;
(0, _snapshot.onWindowReady)(function () {
  (0, _utilEvent["default"])('mousemove').addEventListener(document, pointerTracker);
  (0, _utilEvent["default"])('keydown').addEventListener(document, pageKeyHandler);
});

var useEventMouse = function useEventMouse(props, instances) {
  var scrollMode = props.scrollMode;
  var themeScrollContentHandle = instances.themeScrollContentHandle,
      scrollContainerHandle = instances.scrollContainerHandle; // Functions

  function handleFlick(_ref) {
    var direction = _ref.direction;

    var _scrollContainerHandl = scrollContainerHandle.current,
        canScrollHorizontally = _scrollContainerHandl.canScrollHorizontally,
        canScrollVertically = _scrollContainerHandl.canScrollVertically,
        bounds = scrollContainerHandle.current.getScrollBounds(),
        focusedItem = _spotlight["default"].getCurrent();

    if (focusedItem) {
      focusedItem.blur();
    }

    if ((direction === 'vertical' && canScrollVertically(bounds) || direction === 'horizontal' && canScrollHorizontally(bounds)) && !props['data-spotlight-container-disabled']) {
      themeScrollContentHandle.current.setContainerDisabled(true);
    }
  }

  function handleMouseDown(ev) {
    if (props['data-spotlight-container-disabled']) {
      ev.preventDefault();
    } else if (scrollMode === 'native') {
      themeScrollContentHandle.current.setContainerDisabled(false);
    }
  } // Return


  return {
    handleFlick: handleFlick,
    handleMouseDown: handleMouseDown
  };
};

exports.useEventMouse = useEventMouse;

var useEventTouch = function useEventTouch() {
  // Functions
  function handleTouchStart() {
    var focusedItem = _spotlight["default"].getCurrent();

    if (!_spotlight["default"].isPaused() && focusedItem) {
      focusedItem.blur();
    }
  } // Return


  return {
    handleTouchStart: handleTouchStart
  };
};

exports.useEventTouch = useEventTouch;

var useEventVoice = function useEventVoice(props, instances) {
  var scrollContainerRef = instances.scrollContainerRef,
      scrollContainerHandle = instances.scrollContainerHandle; // Mutable value

  var mutableRef = (0, _react.useRef)({
    isVoiceControl: false,
    voiceControlDirection: 'vertical'
  }); // Functions

  var updateFocusAfterVoiceControl = function updateFocusAfterVoiceControl() {
    var spotItem = _spotlight["default"].getCurrent(),
        scrollContainerNode = scrollContainerRef.current;

    if (_utilDOM["default"].containsDangerously(scrollContainerNode, spotItem)) {
      var viewportBounds = scrollContainerNode.getBoundingClientRect(),
          spotItemBounds = spotItem.getBoundingClientRect(),
          nodes = _spotlight["default"].getSpottableDescendants(scrollContainerNode.dataset.spotlightId),
          first = mutableRef.current.voiceControlDirection === 'vertical' ? 'top' : 'left',
          last = mutableRef.current.voiceControlDirection === 'vertical' ? 'bottom' : 'right';

      if (spotItemBounds[last] < viewportBounds[first] || spotItemBounds[first] > viewportBounds[last]) {
        for (var i = 0; i < nodes.length; i++) {
          var nodeBounds = nodes[i].getBoundingClientRect();

          if (nodeBounds[first] > viewportBounds[first] && nodeBounds[last] < viewportBounds[last]) {
            _spotlight["default"].focus(nodes[i]);

            break;
          }
        }
      }
    }
  };

  function stopVoice() {
    if (mutableRef.current.isVoiceControl) {
      mutableRef.current.isVoiceControl = false;
      updateFocusAfterVoiceControl();
    }
  }

  var isReachedEdge = function isReachedEdge(scrollPos, ltrBound, rtlBound) {
    var isRtl = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
    var bound = isRtl ? rtlBound : ltrBound;
    return bound === 0 && scrollPos === 0 || bound > 0 && scrollPos >= bound - 1;
  };

  var handleVoice = function handleVoice(e) {
    var isHorizontal = props.direction === 'horizontal',
        isRtl = scrollContainerHandle.current.rtl,
        _scrollContainerHandl2 = scrollContainerHandle.current,
        scrollTop = _scrollContainerHandl2.scrollTop,
        scrollLeft = _scrollContainerHandl2.scrollLeft,
        _scrollContainerHandl3 = scrollContainerHandle.current.getScrollBounds(),
        maxLeft = _scrollContainerHandl3.maxLeft,
        maxTop = _scrollContainerHandl3.maxTop,
        verticalDirection = ['up', 'down', 'top', 'bottom'],
        horizontalDirection = isRtl ? ['right', 'left', 'rightmost', 'leftmost'] : ['left', 'right', 'leftmost', 'rightmost'],
        movement = ['previous', 'next', 'first', 'last'];

    var scroll = e && e.detail && e.detail.scroll,
        index = movement.indexOf(scroll);

    if (index > -1) {
      scroll = isHorizontal ? horizontalDirection[index] : verticalDirection[index];
    }

    mutableRef.current.voiceControlDirection = verticalDirection.includes(scroll) && 'vertical' || horizontalDirection.includes(scroll) && 'horizontal' || null; // Case 1. Invalid direction

    if (mutableRef.current.voiceControlDirection === null) {
      mutableRef.current.isVoiceControl = false; // Case 2. Cannot scroll
    } else if (['up', 'top'].includes(scroll) && isReachedEdge(scrollTop, 0) || ['down', 'bottom'].includes(scroll) && isReachedEdge(scrollTop, maxTop) || ['left', 'leftmost'].includes(scroll) && isReachedEdge(scrollLeft, 0, maxLeft, isRtl) || ['right', 'rightmost'].includes(scroll) && isReachedEdge(scrollLeft, maxLeft, 0, isRtl)) {
      if (window.webOSVoiceReportActionResult) {
        window.webOSVoiceReportActionResult({
          voiceUi: {
            exception: 'alreadyCompleted'
          }
        });
        e.preventDefault();
      } // Case 3. Can scroll

    } else {
      mutableRef.current.isVoiceControl = true;

      if (['up', 'down', 'left', 'right'].includes(scroll)) {
        var bounds = scrollContainerHandle.current.getScrollBounds(),
            directionFactor = scroll === 'up' || scroll === 'left' && !isRtl || scroll === 'right' && isRtl,
            scrollVertically = verticalDirection.includes(scroll),
            direction = directionFactor ? -1 : 1,
            pageDistance = direction * (scrollVertically ? bounds.clientHeight : bounds.clientWidth) * paginationPageMultiplier;
        scrollContainerHandle.current.lastInputType = 'pageKey';

        if (direction !== scrollContainerHandle.current.wheelDirection) {
          scrollContainerHandle.current.isScrollAnimationTargetAccumulated = false;
          scrollContainerHandle.current.wheelDirection = direction;
        }

        scrollContainerHandle.current.scrollToAccumulatedTarget(pageDistance, scrollVertically, props.overscrollEffectOn.pageKey);
      } else {
        // ['top', 'bottom', 'leftmost', 'rightmost'].includes(scroll)
        scrollContainerHandle.current.scrollTo({
          align: verticalDirection.includes(scroll) && scroll || (scroll === 'leftmost' && isRtl || scroll === 'rightmost' && !isRtl) && 'right' || 'left'
        });
      }

      e.preventDefault();
    }
  };

  function addVoiceEventListener(scrollContentRef) {
    if (_platform["default"].webos) {
      (0, _utilEvent["default"])('webOSVoice').addEventListener(scrollContentRef, handleVoice);

      if (scrollContainerHandle && scrollContainerHandle.current && scrollContainerHandle.current.getScrollBounds) {
        var bounds = scrollContainerHandle.current.getScrollBounds();

        if (scrollContainerHandle.current.canScrollVertically(bounds) || scrollContainerHandle.current.canScrollHorizontally(bounds)) {
          scrollContentRef.current.setAttribute('data-webos-voice-intent', 'Scroll');
        }
      }
    }
  }

  function removeVoiceEventListener(scrollContentRef) {
    if (_platform["default"].webos) {
      (0, _utilEvent["default"])('webOSVoice').removeEventListener(scrollContentRef, handleVoice);
      scrollContentRef.current.removeAttribute('data-webos-voice-intent');
    }
  } // Return


  return {
    addVoiceEventListener: addVoiceEventListener,
    removeVoiceEventListener: removeVoiceEventListener,
    stopVoice: stopVoice
  };
};

exports.useEventVoice = useEventVoice;

var useEventWheel = function useEventWheel(props, instances) {
  var dataSize = props.dataSize,
      scrollMode = props.scrollMode,
      snapToCenter = props.snapToCenter;
  var themeScrollContentHandle = instances.themeScrollContentHandle,
      scrollContainerHandle = instances.scrollContainerHandle,
      scrollContentHandle = instances.scrollContentHandle,
      scrollContentRef = instances.scrollContentRef,
      spottable = instances.spottable; // Functions

  function initializeWheeling() {
    if (!props['data-spotlight-container-disabled']) {
      themeScrollContentHandle.current.setContainerDisabled(true);
    }

    spottable.current.isWheeling = true;
  }

  function handleWheel(_ref2) {
    var delta = _ref2.delta;

    var focusedItem = _spotlight["default"].getCurrent();

    if (focusedItem) {
      focusedItem.blur();
    }

    if (delta !== 0) {
      initializeWheeling();
    }
  }
  /*
   * wheel event handler;
   * - for horizontal scroll, supports wheel action on any children nodes since web engine cannot support this
   * - for vertical scroll, supports wheel action on scrollbars only
   */


  function handleWheelNative(ev) {
    var overscrollEffectRequired = props.overscrollEffectOn.wheel;
    var bounds = scrollContainerHandle.current.getScrollBounds();
    var canScrollHorizontally = scrollContainerHandle.current.canScrollHorizontally(bounds);
    var canScrollVertically = scrollContainerHandle.current.canScrollVertically(bounds);
    var eventDeltaMode = ev.deltaMode;
    var eventDelta = -ev.wheelDeltaY || ev.deltaY;
    var positiveDelta = eventDelta > 0;
    var negativeDelta = eventDelta < 0;
    var _scrollContainerHandl4 = scrollContainerHandle.current,
        scrollTop = _scrollContainerHandl4.scrollTop,
        scrollLeft = _scrollContainerHandl4.scrollLeft;
    var offset = snapToCenter ? scrollContentHandle.current.primary.gridSize : 0;
    var delta = 0;
    var needToHideScrollbarTrack = false;

    if (typeof window !== 'undefined') {
      window.document.activeElement.blur();
    }

    scrollContainerHandle.current.showScrollbarTrack(bounds); // FIXME This routine is a temporary support for horizontal wheel scroll.
    // FIXME If web engine supports horizontal wheel, this routine should be refined or removed.

    if (canScrollVertically) {
      // This routine handles wheel events on scrollbars for vertical scroll.
      if (negativeDelta && scrollTop > 0 + offset || positiveDelta && scrollTop < bounds.maxTop - offset) {
        if (!spottable.current.isWheeling) {
          initializeWheeling();
        } // If ev.target is a descendant of scrollContent, the event will be handled on scroll event handler.


        if (!_utilDOM["default"].containsDangerously(scrollContentRef.current, ev.target) || snapToCenter) {
          delta = scrollContainerHandle.current.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);
          needToHideScrollbarTrack = !delta;
          ev.preventDefault();
        } else if (overscrollEffectRequired) {
          scrollContainerHandle.current.checkAndApplyOverscrollEffect('vertical', positiveDelta ? 'after' : 'before', overscrollTypeOnce);
        }

        ev.stopPropagation();
      } else {
        if (overscrollEffectRequired && (negativeDelta && scrollTop <= 0 || positiveDelta && scrollTop >= bounds.maxTop)) {
          scrollContainerHandle.current.applyOverscrollEffect('vertical', positiveDelta ? 'after' : 'before', overscrollTypeOnce);
        }

        needToHideScrollbarTrack = true;
      }
    } else if (canScrollHorizontally) {
      // this routine handles wheel events on any children for horizontal scroll.
      if (negativeDelta && scrollLeft > 0 + offset || positiveDelta && scrollLeft < bounds.maxLeft - offset) {
        if (!spottable.current.isWheeling) {
          initializeWheeling();
        }

        delta = scrollContainerHandle.current.calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);
        needToHideScrollbarTrack = !delta;
        ev.preventDefault();
        ev.stopPropagation();
      } else {
        if (overscrollEffectRequired && (negativeDelta && scrollLeft <= 0 || positiveDelta && scrollLeft >= bounds.maxLeft)) {
          scrollContainerHandle.current.applyOverscrollEffect('horizontal', positiveDelta ? 'after' : 'before', overscrollTypeOnce);
        }

        needToHideScrollbarTrack = true;
      }
    }

    if (delta !== 0) {
      /* prevent native scrolling feature for vertical direction */
      ev.preventDefault();
      var direction = Math.sign(delta); // Not to accumulate scroll position if wheel direction is different from hold direction

      if (direction !== scrollContainerHandle.current.wheelDirection) {
        scrollContainerHandle.current.isScrollAnimationTargetAccumulated = false;
        scrollContainerHandle.current.wheelDirection = direction;
      }

      if (!snapToCenter) {
        scrollContainerHandle.current.scrollToAccumulatedTarget(delta, canScrollVertically, overscrollEffectRequired);
      } else {
        var dimensionToExtent = scrollContentHandle.current.dimensionToExtent;
        var currentIndex = scrollContentHandle.current.getCenterItemIndexFromScrollPosition(canScrollVertically ? scrollTop : scrollLeft);
        var nextIndex = currentIndex + direction * dimensionToExtent;

        if (nextIndex > 0 && nextIndex < dataSize - 1) {
          if (typeof document === 'object') {
            var target = document.querySelector("[data-index=\"".concat(nextIndex, "\"] div")); // remove effect

            themeScrollContentHandle.current.removeScaleEffect(); // add effect

            themeScrollContentHandle.current.addScaleEffect(target);
          }

          if (themeScrollContentHandle.current.resetSnapToCenterStatus) {
            themeScrollContentHandle.current.resetSnapToCenterStatus();
          }

          scrollContainerHandle.current.scrollTo({
            index: nextIndex,
            stickTo: 'center'
          });
        }
      }
    }

    if (needToHideScrollbarTrack) {
      scrollContainerHandle.current.startHidingScrollbarTrack();
    }
  } // Return


  return {
    handleWheel: scrollMode === 'translate' ? handleWheel : handleWheelNative
  };
};

exports.useEventWheel = useEventWheel;