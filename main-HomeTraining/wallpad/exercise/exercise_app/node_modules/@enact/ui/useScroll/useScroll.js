"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useScrollBase = exports.useScroll = exports["default"] = exports.constants = exports.assignPropertiesOf = void 0;

var _classnames = _interopRequireDefault(require("classnames"));

var _handle = require("@enact/core/handle");

var _keymap = require("@enact/core/keymap");

var _platform = require("@enact/core/platform");

var _Registry = _interopRequireDefault(require("@enact/core/internal/Registry"));

var _util = require("@enact/core/util");

var _clamp = _interopRequireDefault(require("ramda/src/clamp"));

var _react = require("react");

var _warning = _interopRequireDefault(require("warning"));

var _ForwardRef = _interopRequireDefault(require("../ForwardRef"));

var _Resizable = require("../Resizable");

var _resolution = _interopRequireDefault(require("../resolution"));

var _Touchable = _interopRequireDefault(require("../Touchable"));

var _ScrollAnimator = _interopRequireDefault(require("./ScrollAnimator"));

var _utilDOM = _interopRequireDefault(require("./utilDOM"));

var _utilEvent = _interopRequireDefault(require("./utilEvent"));

var _useScrollModule = _interopRequireDefault(require("./useScroll.module.css"));

var _jsxRuntime = require("react/jsx-runtime");

var _excluded = ["componentRef"],
    _excluded2 = ["childProps", "children", "className", "clientSize", "assignProperties", "dataSize", "direction", "horizontalScrollbar", "horizontalScrollbarHandle", "itemRenderer", "itemSize", "itemSizes", "noScrollByDrag", "noScrollByWheel", "overhang", "overscrollEffectOn", "pageScroll", "role", "rtl", "scrollContainerRef", "scrollContentHandle", "scrollContentRef", "scrollMode", "setScrollContainerHandle", "snapToCenter", "spacing", "spotlightContainerDisabled", "verticalScrollbar", "verticalScrollbarHandle", "wrap"];

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var constants = {
  animationDuration: 1000,
  epsilon: 1,
  flickConfig: {
    maxDuration: null
  },
  isPageDown: (0, _keymap.is)('pageDown'),
  isPageUp: (0, _keymap.is)('pageUp'),
  nop: function nop() {},
  overscrollDefaultRatio: 0.5,
  overscrollTypeNone: 0,
  overscrollTypeHold: 1,
  overscrollTypeOnce: 2,
  overscrollTypeDone: 9,
  overscrollVelocityFactor: 300,
  // scrollMode 'native'
  paginationPageMultiplier: 0.66,
  scrollStopWaiting: 200,
  scrollWheelPageMultiplierForMaxPixel: 0.2 // The ratio of the maximum distance scrolled by wheel to the size of the viewport.

},
    animationDuration = constants.animationDuration,
    epsilon = constants.epsilon,
    flickConfig = constants.flickConfig,
    isPageDown = constants.isPageDown,
    isPageUp = constants.isPageUp,
    overscrollDefaultRatio = constants.overscrollDefaultRatio,
    overscrollTypeDone = constants.overscrollTypeDone,
    overscrollTypeHold = constants.overscrollTypeHold,
    overscrollTypeNone = constants.overscrollTypeNone,
    overscrollTypeOnce = constants.overscrollTypeOnce,
    overscrollVelocityFactor = constants.overscrollVelocityFactor,
    paginationPageMultiplier = constants.paginationPageMultiplier,
    scrollStopWaiting = constants.scrollStopWaiting,
    scrollWheelPageMultiplierForMaxPixel = constants.scrollWheelPageMultiplierForMaxPixel;
exports.constants = constants;
var TouchableDiv = (0, _ForwardRef["default"])({
  prop: 'componentRef'
}, (0, _Touchable["default"])(function (_ref) {
  var componentRef = _ref.componentRef,
      rest = _objectWithoutProperties(_ref, _excluded);

  return /*#__PURE__*/(0, _jsxRuntime.jsx)("div", _objectSpread(_objectSpread({}, rest), {}, {
    ref: componentRef
  }));
}));

var useForceUpdate = function useForceUpdate() {
  return (0, _react.useReducer)(function (x) {
    return x + 1;
  }, 0);
};
/**
 * A custom hook that passes scrollable behavior information as its render prop.
 *
 * @class
 * @memberof ui/useScroll
 * @ui
 * @private
 */


var useScrollBase = function useScrollBase(props) {
  var childProps = props.childProps,
      children = props.children,
      className = props.className,
      clientSize = props.clientSize,
      assignProperties = props.assignProperties,
      dataSize = props.dataSize,
      direction = props.direction,
      horizontalScrollbar = props.horizontalScrollbar,
      horizontalScrollbarHandle = props.horizontalScrollbarHandle,
      itemRenderer = props.itemRenderer,
      itemSize = props.itemSize,
      itemSizes = props.itemSizes,
      noScrollByDrag = props.noScrollByDrag,
      noScrollByWheel = props.noScrollByWheel,
      overhang = props.overhang,
      overscrollEffectOn = props.overscrollEffectOn,
      pageScroll = props.pageScroll,
      role = props.role,
      rtl = props.rtl,
      scrollContainerRef = props.scrollContainerRef,
      scrollContentHandle = props.scrollContentHandle,
      scrollContentRef = props.scrollContentRef,
      scrollMode = props.scrollMode,
      setScrollContainerHandle = props.setScrollContainerHandle,
      snapToCenter = props.snapToCenter,
      spacing = props.spacing,
      spotlightContainerDisabled = props.spotlightContainerDisabled,
      verticalScrollbar = props.verticalScrollbar,
      verticalScrollbarHandle = props.verticalScrollbarHandle,
      wrap = props.wrap,
      rest = _objectWithoutProperties(props, _excluded2),
      scrollClasses = (0, _classnames["default"])(_useScrollModule["default"].scroll, className); // The following props are the one having the same naming function in this scope.
  // So it is better to use props[propName]
  // instead of extracting it from the `props` and renaming it


  delete rest.addEventListeners;
  delete rest.applyOverscrollEffect;
  delete rest.cbScrollTo;
  delete rest.clearOverscrollEffect;
  delete rest.handleResizeWindow;
  delete rest.onFlick;
  delete rest.onKeyDown;
  delete rest.onMouseDown;
  delete rest.onScroll;
  delete rest.onScrollStart;
  delete rest.onScrollStop;
  delete rest.onWheel;
  delete rest.removeEventListeners;
  delete rest.scrollStopOnScroll; // scrollMode 'native'

  delete rest.scrollTo;
  delete rest.start; // scrollMode 'native'

  delete rest.stop; // scrollMode 'translate'
  // Mutable value and Hooks

  var _useForceUpdate = useForceUpdate(),
      _useForceUpdate2 = _slicedToArray(_useForceUpdate, 2),
      forceUpdate = _useForceUpdate2[1];

  var context = (0, _react.useContext)(_Resizable.ResizeContext);

  var _useState = (0, _react.useState)(horizontalScrollbar === 'visible'),
      _useState2 = _slicedToArray(_useState, 2),
      isHorizontalScrollbarVisible = _useState2[0],
      setIsHorizontalScrollbarVisible = _useState2[1];

  var _useState3 = (0, _react.useState)(verticalScrollbar === 'visible'),
      _useState4 = _slicedToArray(_useState3, 2),
      isVerticalScrollbarVisible = _useState4[0],
      setIsVerticalScrollbarVisible = _useState4[1];

  var mutableRef = (0, _react.useRef)({
    overscrollEnabled: !!props.applyOverscrollEffect,
    // Enable the early bail out of repeated scrolling to the same position
    animationInfo: null,
    resizeRegistry: null,
    // constants
    pixelPerLine: 39,
    scrollWheelMultiplierForDeltaPixel: 1.5,
    // The ratio of wheel 'delta' units to pixels scrolled.
    // status
    deferScrollTo: true,
    isScrollAnimationTargetAccumulated: false,
    // overscroll
    lastInputType: null,
    overscrollStatus: {
      horizontal: {
        before: {
          type: overscrollTypeNone,
          ratio: 0
        },
        after: {
          type: overscrollTypeNone,
          ratio: 0
        }
      },
      vertical: {
        before: {
          type: overscrollTypeNone,
          ratio: 0
        },
        after: {
          type: overscrollTypeNone,
          ratio: 0
        }
      }
    },
    // bounds info
    bounds: {
      clientWidth: 0,
      clientHeight: 0,
      scrollWidth: 0,
      scrollHeight: 0,
      maxTop: 0,
      maxLeft: 0
    },
    // wheel/drag/flick info
    wheelDirection: 0,
    isDragging: false,
    isTouching: false,
    // scrollMode 'native'
    // scroll info
    scrolling: false,
    scrollLeft: 0,
    scrollTop: 0,
    scrollToInfo: null,
    // scroll animator
    animator: null,
    // scroll status observer
    observerOnScroll: [],
    // non-declared-variable.
    accumulatedTargetX: null,
    accumulatedTargetY: null,
    flickTarget: null,
    dragStartX: null,
    dragStartY: null,
    scrollStopJob: null,
    prevState: {
      isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,
      isVerticalScrollbarVisible: isVerticalScrollbarVisible
    }
  });

  if (mutableRef.current.animator == null) {
    mutableRef.current.animator = new _ScrollAnimator["default"]();
  }

  (0, _react.useLayoutEffect)(function () {
    if (setScrollContainerHandle) {
      setScrollContainerHandle({
        animator: mutableRef.current.animator,
        applyOverscrollEffect: applyOverscrollEffect,
        bounds: mutableRef.current.bounds,
        calculateDistanceByWheel: calculateDistanceByWheel,
        canScrollHorizontally: canScrollHorizontally,
        canScrollVertically: canScrollVertically,
        checkAndApplyOverscrollEffect: checkAndApplyOverscrollEffect,
        getScrollBounds: getScrollBounds,

        get isDragging() {
          return mutableRef.current.isDragging;
        },

        set isDragging(val) {
          mutableRef.current.isDragging = val;
        },

        get isScrollAnimationTargetAccumulated() {
          return mutableRef.current.isScrollAnimationTargetAccumulated;
        },

        set isScrollAnimationTargetAccumulated(val) {
          mutableRef.current.isScrollAnimationTargetAccumulated = val;
        },

        get lastInputType() {
          return mutableRef.current.lastInputType;
        },

        set lastInputType(val) {
          mutableRef.current.lastInputType = val;
        },

        get rtl() {
          return rtl;
        },

        get scrollBounds() {
          return getScrollBounds();
        },

        get scrollHeight() {
          return mutableRef.current.bounds.scrollHeight;
        },

        get scrolling() {
          return mutableRef.current.scrolling;
        },

        get scrollLeft() {
          return mutableRef.current.scrollLeft;
        },

        scrollTo: scrollTo,
        scrollToAccumulatedTarget: scrollToAccumulatedTarget,

        get scrollToInfo() {
          return mutableRef.current.scrollToInfo;
        },

        get scrollTop() {
          return mutableRef.current.scrollTop;
        },

        setOverscrollStatus: setOverscrollStatus,
        showScrollbarTrack: showScrollbarTrack,
        start: start,
        startHidingScrollbarTrack: startHidingScrollbarTrack,
        stop: stop,

        get wheelDirection() {
          return mutableRef.current.wheelDirection;
        },

        set wheelDirection(val) {
          mutableRef.current.wheelDirection = val;
        }

      });
    }
  });
  (0, _react.useLayoutEffect)(function () {
    if (props.cbScrollTo) {
      props.cbScrollTo(scrollTo);
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  (0, _react.useLayoutEffect)(function () {
    var containerRef = scrollContainerRef.current;

    if (!containerRef) {
      return;
    }

    if (typeof ResizeObserver === 'function') {
      var resizeObserver = new ResizeObserver(function () {
        if (scrollContentHandle.current && scrollContentHandle.current.syncClientSize) {
          scrollContentHandle.current.syncClientSize();
        }
      });
      resizeObserver.observe(containerRef);
      return function () {
        if (resizeObserver) {
          resizeObserver.disconnect();
          resizeObserver = null;
        }
      };
    }
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  (0, _react.useLayoutEffect)(function () {
    mutableRef.current.resizeRegistry.parent = context; // componentWillUnmount

    return function () {
      var _mutableRef$current = mutableRef.current,
          animator = _mutableRef$current.animator,
          resizeRegistry = _mutableRef$current.resizeRegistry,
          scrolling = _mutableRef$current.scrolling,
          scrollStopJob = _mutableRef$current.scrollStopJob; // eslint-disable-line react-hooks/exhaustive-deps

      resizeRegistry.parent = null; // Before call cancelAnimationFrame, you must send scrollStop Event.

      if (scrolling) {
        forwardScrollEvent('onScrollStop', getReachedEdgeInfo());
      }

      scrollStopJob.stop(); // scrollMode 'translate' [

      if (animator.isAnimating()) {
        animator.stop();
      } // scrollMode 'translate' ]

    };
  }, []); // eslint-disable-line react-hooks/exhaustive-deps

  (0, _react.useEffect)(function () {
    addEventListeners();
    return function () {
      removeEventListeners();
    };
  }); // scrollMode 'translate' [[
  // TODO: consider replacing forceUpdate() by storing bounds in state rather than a non-
  // state member.

  var enqueueForceUpdate = (0, _react.useCallback)(function () {
    scrollContentHandle.current.calculateMetrics(scrollContentHandle.current.props);
    forceUpdate();
  }, [forceUpdate, scrollContentHandle]); // scrollMode 'translate' ]]

  function handleResizeWindow() {
    var propsHandleResizeWindow = props.handleResizeWindow; // `handleSize` in `ui/resolution.ResolutionDecorator` should be executed first.

    setTimeout(function () {
      var handleResizeResult = propsHandleResizeWindow === null || propsHandleResizeWindow === void 0 ? void 0 : propsHandleResizeWindow();

      if (handleResizeResult) {
        if (scrollMode === 'translate') {
          scrollTo({
            position: {
              x: 0,
              y: 0
            },
            animate: false
          });
        } else {
          scrollContentHandle.current.scrollToPosition(0, 0, 'instant');
        }
      }

      enqueueForceUpdate();
    });
  } // scrollMode 'translate' [[


  var handleResize = (0, _react.useCallback)(function (ev) {
    if (ev.action === 'invalidateBounds') {
      enqueueForceUpdate();
    }
  }, [enqueueForceUpdate]); // scrollMode 'translate' ]]

  if (mutableRef.current.resizeRegistry == null) {
    mutableRef.current.resizeRegistry = _Registry["default"].create(handleResize);
  }

  (0, _react.useLayoutEffect)(function () {
    var ref = mutableRef.current;

    if (scrollMode === 'translate') {
      ref.scrollStopJob = new _util.Job(doScrollStop, scrollStopWaiting);
    } else {
      ref.scrollStopJob = new _util.Job(scrollStopOnScroll, scrollStopWaiting);
    }

    return function () {
      if (ref.scrolling) {
        ref.scrollStopJob.run();
      }

      ref.scrollStopJob.stop();
    };
  }, [direction, isHorizontalScrollbarVisible, isVerticalScrollbarVisible, rtl, scrollMode, spotlightContainerDisabled]); // eslint-disable-line react-hooks/exhaustive-deps

  (0, _react.useLayoutEffect)(function () {
    var hasDataSizeChanged = scrollContentHandle.current.hasDataSizeChanged,
        _mutableRef$current2 = mutableRef.current,
        prevState = _mutableRef$current2.prevState,
        resizeRegistry = _mutableRef$current2.resizeRegistry,
        scrollToInfo = _mutableRef$current2.scrollToInfo; // Need to sync calculated client size if it is different from the real size

    if (scrollContentHandle.current.syncClientSize) {
      // If we actually synced, we need to reset scroll position.
      if (scrollContentHandle.current.syncClientSize()) {
        setScrollLeft(0);
        setScrollTop(0);
      }
    }

    clampScrollPosition(); // scrollMode 'translate'

    if (hasDataSizeChanged === false && (isHorizontalScrollbarVisible && !prevState.isHorizontalScrollbarVisible || isVerticalScrollbarVisible && !prevState.isVerticalScrollbarVisible)) {
      mutableRef.current.deferScrollTo = false;
      updateScrollbarTrackSize();
    } else {
      updateScrollbars();
    }

    if (scrollToInfo !== null) {
      if (!mutableRef.current.deferScrollTo) {
        scrollTo(scrollToInfo);
      }
    } // publish container resize changes


    var horizontal = isHorizontalScrollbarVisible !== prevState.isHorizontalScrollbarVisible;
    var vertical = isVerticalScrollbarVisible !== prevState.isVerticalScrollbarVisible;

    if (horizontal || vertical) {
      resizeRegistry.notify({});
    }
  }); // scrollMode 'translate' [[

  function clampScrollPosition() {
    var bounds = getScrollBounds();

    if (mutableRef.current.scrollTop > bounds.maxTop) {
      mutableRef.current.scrollTop = bounds.maxTop;
    }

    if (mutableRef.current.scrollLeft > bounds.maxLeft) {
      mutableRef.current.scrollLeft = bounds.maxLeft;
    }
  } // scrollMode 'translate' ]]
  // drag/flick event handlers


  function getRtlX(x) {
    return rtl ? -x : x;
  }

  function onMouseDown(ev) {
    if (snapToCenter) {
      ev.preventDefault();
    }

    if ((0, _handle.forwardWithPrevent)('onMouseDown', ev, props) && !snapToCenter) {
      stop();
    }
  } // scrollMode 'native' [[


  function onTouchStart() {
    mutableRef.current.isTouching = true;
  } // scrollMode 'native' ]]


  function onDragStart(ev) {
    if (scrollMode === 'translate') {
      if (ev.type === 'dragstart') return;
      (0, _handle.forward)('onDragStart', ev, props);
      stop();
      mutableRef.current.isDragging = true;
      mutableRef.current.dragStartX = mutableRef.current.scrollLeft + getRtlX(ev.x);
      mutableRef.current.dragStartY = mutableRef.current.scrollTop + ev.y;
    } else {
      if (!mutableRef.current.isTouching) {
        stop();
        mutableRef.current.isDragging = true;
      } // these values are used also for touch inputs


      mutableRef.current.dragStartX = mutableRef.current.scrollLeft + getRtlX(ev.x);
      mutableRef.current.dragStartY = mutableRef.current.scrollTop + ev.y;
    }
  }

  function onDrag(ev) {
    if (scrollMode === 'translate') {
      if (ev.type === 'drag') {
        return;
      }

      mutableRef.current.lastInputType = 'drag';
      (0, _handle.forward)('onDrag', ev, props);
      start({
        targetX: direction === 'vertical' ? 0 : mutableRef.current.dragStartX - getRtlX(ev.x),
        // 'horizontal' or 'both'
        targetY: direction === 'horizontal' ? 0 : mutableRef.current.dragStartY - ev.y,
        // 'vertical' or 'both'
        animate: false,
        overscrollEffect: overscrollEffectOn && overscrollEffectOn.drag
      });
    } else {
      var targetX = direction === 'vertical' ? 0 : mutableRef.current.dragStartX - getRtlX(ev.x),
          // 'horizontal' or 'both'
      targetY = direction === 'horizontal' ? 0 : mutableRef.current.dragStartY - ev.y; // 'vertical' or 'both'

      mutableRef.current.lastInputType = 'drag';

      if (!mutableRef.current.isTouching) {
        start({
          targetX: targetX,
          targetY: targetY,
          animate: false,
          overscrollEffect: overscrollEffectOn && overscrollEffectOn.drag
        });
      } else if (mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn.drag) {
        checkAndApplyOverscrollEffectOnDrag(targetX, targetY, overscrollTypeHold);
      }
    }
  }

  function onDragEnd(ev) {
    if (scrollMode === 'translate') {
      if (ev.type === 'dragend') {
        return;
      }

      mutableRef.current.isDragging = false;
      (0, _handle.forward)('onDragEnd', ev, props);

      if (mutableRef.current.flickTarget) {
        var _mutableRef$current$f = mutableRef.current.flickTarget,
            targetX = _mutableRef$current$f.targetX,
            targetY = _mutableRef$current$f.targetY,
            duration = _mutableRef$current$f.duration;
        mutableRef.current.lastInputType = 'drag';
        mutableRef.current.isScrollAnimationTargetAccumulated = false;
        start({
          targetX: targetX,
          targetY: targetY,
          duration: duration,
          overscrollEffect: overscrollEffectOn && overscrollEffectOn.drag
        });
      } else {
        stop();
      }

      if (mutableRef.current.overscrollEnabled) {
        // not check overscrollEffectOn && overscrollEffectOn.drag for safety
        clearAllOverscrollEffects();
      }

      mutableRef.current.flickTarget = null;
    } else {
      mutableRef.current.isDragging = false;
      mutableRef.current.lastInputType = 'drag';

      if (mutableRef.current.flickTarget) {
        var _mutableRef$current$f2 = mutableRef.current.flickTarget,
            _targetX = _mutableRef$current$f2.targetX,
            _targetY = _mutableRef$current$f2.targetY;

        if (!mutableRef.current.isTouching) {
          mutableRef.current.isScrollAnimationTargetAccumulated = false;
          start({
            targetX: _targetX,
            targetY: _targetY,
            overscrollEffect: overscrollEffectOn && overscrollEffectOn.drag
          });
        } else if (mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn.drag) {
          checkAndApplyOverscrollEffectOnDrag(_targetX, _targetY, overscrollTypeOnce);
        }
      } else if (!mutableRef.current.isTouching) {
        stop();
      }

      if (mutableRef.current.overscrollEnabled) {
        // not check overscrollEffectOn && overscrollEffectOn.drag for safety
        clearAllOverscrollEffects();
      }

      mutableRef.current.isTouching = false;
      mutableRef.current.flickTarget = null;
    }
  }

  function onFlick(ev) {
    var isVerticalFlick = ev.direction === 'vertical';

    if (scrollMode === 'translate' || !mutableRef.current.isTouching) {
      // except touch input in 'native' mode
      mutableRef.current.flickTarget = mutableRef.current.animator.simulate(mutableRef.current.scrollLeft, mutableRef.current.scrollTop, direction !== 'vertical' && !isVerticalFlick ? getRtlX(-ev.velocityX) : 0, direction !== 'horizontal' && isVerticalFlick ? -ev.velocityY : 0);
    } else if (mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn.drag) {
      // overscroll is required on touch input in 'native' mode
      mutableRef.current.flickTarget = {
        targetX: mutableRef.current.scrollLeft + (!isVerticalFlick ? getRtlX(-ev.velocityX) : 0) * overscrollVelocityFactor,
        // 'horizontal' or 'both'
        targetY: mutableRef.current.scrollTop + (isVerticalFlick ? -ev.velocityY : 0) * overscrollVelocityFactor // 'vertical' or 'both'

      };
    }

    if (props.onFlick) {
      (0, _handle.forward)('onFlick', ev, props);
    }
  }

  function calculateDistanceByWheel(deltaMode, delta, maxPixel) {
    if (deltaMode === 0) {
      delta = (0, _clamp["default"])(-maxPixel, maxPixel, _resolution["default"].scale(delta * mutableRef.current.scrollWheelMultiplierForDeltaPixel));
    } else if (deltaMode === 1) {
      // line; firefox
      delta = (0, _clamp["default"])(-maxPixel, maxPixel, _resolution["default"].scale(delta * mutableRef.current.pixelPerLine * mutableRef.current.scrollWheelMultiplierForDeltaPixel));
    } else if (deltaMode === 2) {
      // page
      delta = delta < 0 ? -maxPixel : maxPixel;
    }

    return delta;
  }
  /*
   * wheel event handler;
   * - for horizontal scroll, supports wheel action on any children nodes since web engine cannot support this
   * - for vertical scroll, supports wheel action on scrollbars only
   */


  function onWheel(ev) {
    if (mutableRef.current.isDragging) {
      ev.preventDefault();
      ev.stopPropagation();
    } else {
      var bounds = getScrollBounds(),
          canScrollH = canScrollHorizontally(bounds),
          canScrollV = canScrollVertically(bounds),
          eventDeltaMode = ev.deltaMode,
          eventDelta = -ev.wheelDeltaY || ev.deltaY;
      var delta = 0;
      mutableRef.current.lastInputType = 'wheel';

      if (noScrollByWheel) {
        if (scrollMode === 'native' && canScrollV) {
          ev.preventDefault();
        }

        return;
      }

      if (snapToCenter) {
        if (scrollMode === 'native' && (canScrollV || canScrollH)) {
          ev.preventDefault();
          (0, _handle.forward)('onWheel', ev, props);
          return;
        }
      }

      if (scrollMode === 'translate') {
        if (canScrollV) {
          delta = calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);
        } else if (canScrollH) {
          delta = calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);
        }

        var dir = Math.sign(delta);

        if (dir !== mutableRef.current.wheelDirection) {
          mutableRef.current.isScrollAnimationTargetAccumulated = false;
          mutableRef.current.wheelDirection = dir;
        }

        (0, _handle.forward)('onWheel', {
          delta: delta,
          horizontalScrollbarHandle: horizontalScrollbarHandle,
          verticalScrollbarHandle: verticalScrollbarHandle
        }, props);

        if (delta !== 0) {
          scrollToAccumulatedTarget(delta, canScrollV, overscrollEffectOn && overscrollEffectOn.wheel);
          ev.preventDefault();
          ev.stopPropagation();
        }
      } else {
        // scrollMode 'native'
        var overscrollEffectRequired = mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn.wheel;
        var needToHideScrollbarTrack = false;

        if (props.onWheel) {
          (0, _handle.forward)('onWheel', ev, props);
          return;
        }

        showScrollbarTrack(bounds); // FIXME This routine is a temporary support for horizontal wheel scroll.
        // FIXME If web engine supports horizontal wheel, this routine should be refined or removed.

        if (canScrollV) {
          // This routine handles wheel events on scrollbars for vertical scroll.
          if (eventDelta < 0 && mutableRef.current.scrollTop > 0 || eventDelta > 0 && mutableRef.current.scrollTop < bounds.maxTop) {
            // Not to check if ev.target is a descendant of a wrapped component which may have a lot of nodes in it.
            if (horizontalScrollbarHandle.current && horizontalScrollbarHandle.current.getContainerRef && _utilDOM["default"].containsDangerously(horizontalScrollbarHandle.current.getContainerRef(), ev.target) || verticalScrollbarHandle.current && verticalScrollbarHandle.current.getContainerRef && _utilDOM["default"].containsDangerously(verticalScrollbarHandle.current.getContainerRef(), ev.target)) {
              delta = calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientHeight * scrollWheelPageMultiplierForMaxPixel);
              needToHideScrollbarTrack = !delta;
              ev.preventDefault();
            } else if (overscrollEffectRequired) {
              checkAndApplyOverscrollEffect('vertical', eventDelta > 0 ? 'after' : 'before', overscrollTypeOnce);
            }

            ev.stopPropagation();
          } else {
            if (overscrollEffectRequired && (eventDelta < 0 && mutableRef.current.scrollTop <= 0 || eventDelta > 0 && mutableRef.current.scrollTop >= bounds.maxTop)) {
              applyOverscrollEffect('vertical', eventDelta > 0 ? 'after' : 'before', overscrollTypeOnce);
            }

            needToHideScrollbarTrack = true;
          }
        } else if (canScrollH) {
          // this routine handles wheel events on any children for horizontal scroll.
          if (eventDelta < 0 && mutableRef.current.scrollLeft > 0 || eventDelta > 0 && mutableRef.current.scrollLeft < bounds.maxLeft) {
            delta = calculateDistanceByWheel(eventDeltaMode, eventDelta, bounds.clientWidth * scrollWheelPageMultiplierForMaxPixel);
            needToHideScrollbarTrack = !delta;
            ev.preventDefault();
            ev.stopPropagation();
          } else {
            if (overscrollEffectRequired && (eventDelta < 0 && mutableRef.current.scrollLeft <= 0 || eventDelta > 0 && mutableRef.current.scrollLeft >= bounds.maxLeft)) {
              applyOverscrollEffect('horizontal', eventDelta > 0 ? 'after' : 'before', overscrollTypeOnce);
            }

            needToHideScrollbarTrack = true;
          }
        }

        if (delta !== 0) {
          var _dir = Math.sign(delta); // Not to accumulate scroll position if wheel direction is different from hold direction


          if (_dir !== mutableRef.current.wheelDirection) {
            mutableRef.current.isScrollAnimationTargetAccumulated = false;
            mutableRef.current.wheelDirection = _dir;
          }

          scrollToAccumulatedTarget(delta, canScrollV, overscrollEffectOn && overscrollEffectOn.wheel);
        }

        if (needToHideScrollbarTrack) {
          startHidingScrollbarTrack();
        }
      }
    }
  } // scrollMode 'translate' [[


  function scrollByPage(keyCode) {
    var bounds = getScrollBounds(),
        canScrollV = canScrollVertically(bounds),
        pageDistance = (isPageUp(keyCode) ? -1 : 1) * (canScrollV ? bounds.clientHeight : bounds.clientWidth) * paginationPageMultiplier;
    mutableRef.current.lastInputType = 'pageKey';
    scrollToAccumulatedTarget(pageDistance, canScrollV, overscrollEffectOn && overscrollEffectOn.pageKey);
  } // scrollMode 'translate' ]]
  // scrollMode 'native' [[


  function onScroll(ev) {
    var _ev$target = ev.target,
        scrollLeft = _ev$target.scrollLeft,
        scrollTop = _ev$target.scrollTop;
    var bounds = getScrollBounds(),
        canScrollH = canScrollHorizontally(bounds);

    if (!mutableRef.current.scrolling) {
      scrollStartOnScroll();
    }

    if (rtl && canScrollH) {
      scrollLeft = _platform.platform.ios || _platform.platform.safari || _platform.platform.chrome >= 85 || _platform.platform.androidChrome >= 85 ? -scrollLeft : bounds.maxLeft - scrollLeft;
    }

    if (scrollLeft !== mutableRef.current.scrollLeft) {
      setScrollLeft(scrollLeft);
    }

    if (scrollTop !== mutableRef.current.scrollTop) {
      setScrollTop(scrollTop);
    }

    if (scrollContentHandle.current.didScroll) {
      scrollContentHandle.current.didScroll(mutableRef.current.scrollLeft, mutableRef.current.scrollTop);
    }

    forwardScrollEvent('onScroll');
    mutableRef.current.scrollStopJob.start();
  } // scrollMode 'native' ]]


  function onKeyDown(ev) {
    if (scrollMode === 'translate') {
      if (props.onKeyDown) {
        (0, _handle.forward)('onKeyDown', ev, props);
      } else if (isPageUp(ev.keyCode) || isPageDown(ev.keyCode)) {
        scrollByPage(ev.keyCode);
      }
    } else {
      (0, _handle.forward)('onKeyDown', ev, props);
    }
  }

  function scrollToAccumulatedTarget(delta, vertical, overscrollEffect) {
    if (!mutableRef.current.isScrollAnimationTargetAccumulated) {
      mutableRef.current.accumulatedTargetX = mutableRef.current.scrollLeft;
      mutableRef.current.accumulatedTargetY = mutableRef.current.scrollTop;
      mutableRef.current.isScrollAnimationTargetAccumulated = true;
    }

    if (vertical) {
      mutableRef.current.accumulatedTargetY += delta;
    } else {
      mutableRef.current.accumulatedTargetX += delta;
    }

    start({
      targetX: mutableRef.current.accumulatedTargetX,
      targetY: mutableRef.current.accumulatedTargetY,
      overscrollEffect: overscrollEffect
    });
  } // overscroll effect


  function getEdgeFromPosition(position, maxPosition) {
    if (position <= 0) {
      return 'before';
    } else if (position >= maxPosition - epsilon) {
      return 'after';
    } else {
      return null;
    }
  }

  function setOverscrollStatus(orientation, edge, overscrollEffectType, ratio) {
    var status = mutableRef.current.overscrollStatus[orientation][edge];
    status.type = overscrollEffectType;
    status.ratio = ratio;
  }

  function getOverscrollStatus(orientation, edge) {
    return mutableRef.current.overscrollStatus[orientation][edge];
  }

  function calculateOverscrollRatio(orientation, position) {
    var bounds = getScrollBounds(),
        isVertical = orientation === 'vertical',
        baseSize = isVertical ? bounds.clientHeight : bounds.clientWidth,
        maxPos = bounds[isVertical ? 'maxTop' : 'maxLeft'];
    var overDistance = 0;

    if (position < 0) {
      overDistance = -position;
    } else if (position > maxPos) {
      overDistance = position - maxPos;
    } else {
      return 0;
    }

    return Math.min(1, 2 * overDistance / baseSize);
  }

  function applyOverscrollEffect(orientation, edge, overscrollEffectType) {
    var ratio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : overscrollDefaultRatio;
    props.applyOverscrollEffect(orientation, edge, overscrollEffectType, ratio);
    setOverscrollStatus(orientation, edge, overscrollEffectType === overscrollTypeOnce ? overscrollTypeDone : overscrollEffectType, ratio);
  }

  function checkAndApplyOverscrollEffect(orientation, edge, overscrollEffectType) {
    var ratio = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : overscrollDefaultRatio;
    var isVertical = orientation === 'vertical',
        curPos = isVertical ? mutableRef.current.scrollTop : mutableRef.current.scrollLeft,
        maxPos = getScrollBounds()[isVertical ? 'maxTop' : 'maxLeft'];

    if (edge === 'before' && curPos <= 0 || edge === 'after' && curPos >= maxPos - epsilon) {
      // Already on the edge
      applyOverscrollEffect(orientation, edge, overscrollEffectType, ratio);
    } else {
      setOverscrollStatus(orientation, edge, overscrollEffectType, ratio);
    }
  }

  function clearOverscrollEffect(orientation, edge) {
    if (getOverscrollStatus(orientation, edge).type !== overscrollTypeNone) {
      if (props.clearOverscrollEffect) {
        props.clearOverscrollEffect(orientation, edge);
      } else {
        applyOverscrollEffect(orientation, edge, overscrollTypeNone, 0);
      }
    }
  }

  function clearAllOverscrollEffects() {
    ['horizontal', 'vertical'].forEach(function (orientation) {
      ['before', 'after'].forEach(function (edge) {
        clearOverscrollEffect(orientation, edge);
      });
    });
  }

  function applyOverscrollEffectOnDrag(orientation, edge, targetPosition, overscrollEffectType) {
    if (edge) {
      var oppositeEdge = edge === 'before' ? 'after' : 'before',
          ratio = calculateOverscrollRatio(orientation, targetPosition);
      applyOverscrollEffect(orientation, edge, overscrollEffectType, ratio);
      clearOverscrollEffect(orientation, oppositeEdge);
    } else {
      clearOverscrollEffect(orientation, 'before');
      clearOverscrollEffect(orientation, 'after');
    }
  } // scrollMode 'native' [[


  function checkAndApplyOverscrollEffectOnDrag(targetX, targetY, overscrollEffectType) {
    var bounds = getScrollBounds();

    if (canScrollHorizontally(bounds)) {
      applyOverscrollEffectOnDrag('horizontal', getEdgeFromPosition(targetX, bounds.maxLeft), targetX, overscrollEffectType);
    }

    if (canScrollVertically(bounds)) {
      applyOverscrollEffectOnDrag('vertical', getEdgeFromPosition(targetY, bounds.maxTop), targetY, overscrollEffectType);
    }
  } // scrollMode 'native' ]]


  function checkAndApplyOverscrollEffectOnScroll(orientation) {
    ['before', 'after'].forEach(function (edge) {
      var _getOverscrollStatus = getOverscrollStatus(orientation, edge),
          ratio = _getOverscrollStatus.ratio,
          overscrollEffectType = _getOverscrollStatus.type;

      if (overscrollEffectType === overscrollTypeOnce) {
        checkAndApplyOverscrollEffect(orientation, edge, overscrollEffectType, ratio);
      }
    });
  }

  function checkAndApplyOverscrollEffectOnStart(orientation, edge, targetPosition) {
    if (mutableRef.current.isDragging) {
      applyOverscrollEffectOnDrag(orientation, edge, targetPosition, overscrollTypeHold);
    } else if (edge) {
      checkAndApplyOverscrollEffect(orientation, edge, overscrollTypeOnce);
    }
  } // call scroll callbacks


  var addObserverOnScroll = (0, _react.useCallback)(function (fn) {
    var observerOnScroll = mutableRef.current.observerOnScroll;

    if (typeof fn === 'function' && !observerOnScroll.includes(fn)) {
      observerOnScroll.push(fn);
    }
  }, []);
  var removeObserverOnScroll = (0, _react.useCallback)(function (fn) {
    var observerOnScroll = mutableRef.current.observerOnScroll;
    var index = observerOnScroll.indexOf(fn);

    if (index !== -1) {
      observerOnScroll.splice(index, 1);
    }
  }, []);

  function forwardScrollEvent(type, reachedEdgeInfo) {
    var data = {
      scrollLeft: mutableRef.current.scrollLeft,
      scrollTop: mutableRef.current.scrollTop,
      moreInfo: getMoreInfo(),
      reachedEdgeInfo: reachedEdgeInfo
    };
    (0, _handle.forward)(type, data, props);

    if (type === 'onScroll') {
      mutableRef.current.observerOnScroll.forEach(function (fn) {
        return fn(data);
      });
    }
  } // scrollMode 'native' [[
  // call scroll callbacks and update scrollbars for native scroll


  function scrollStartOnScroll() {
    mutableRef.current.scrolling = true;
    showScrollbarTrack(getScrollBounds());
    forwardScrollEvent('onScrollStart');
  }

  function scrollStopOnScroll() {
    if (props.scrollStopOnScroll) {
      props.scrollStopOnScroll();
    }

    if (mutableRef.current.overscrollEnabled && !mutableRef.current.isDragging) {
      // not check overscrollEffectOn && overscrollEffectOn for safety
      clearAllOverscrollEffects();
    }

    mutableRef.current.lastInputType = null;
    mutableRef.current.isScrollAnimationTargetAccumulated = false;
    mutableRef.current.scrolling = false;
    forwardScrollEvent('onScrollStop', getReachedEdgeInfo());
    startHidingScrollbarTrack();
  } // scrollMode 'native' ]]
  // update scroll position


  function setScrollLeft(value) {
    var bounds = getScrollBounds();
    mutableRef.current.scrollLeft = (0, _clamp["default"])(0, bounds.maxLeft, value);

    if (mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn[mutableRef.current.lastInputType]) {
      checkAndApplyOverscrollEffectOnScroll('horizontal');
    }

    if (isHorizontalScrollbarVisible) {
      updateScrollbarTrack(horizontalScrollbarHandle, bounds);
    }
  }

  function setScrollTop(value) {
    var bounds = getScrollBounds();
    mutableRef.current.scrollTop = (0, _clamp["default"])(0, bounds.maxTop, value);

    if (mutableRef.current.overscrollEnabled && overscrollEffectOn && overscrollEffectOn[mutableRef.current.lastInputType]) {
      checkAndApplyOverscrollEffectOnScroll('vertical');
    }

    if (isVerticalScrollbarVisible) {
      updateScrollbarTrack(verticalScrollbarHandle, bounds);
    }
  }

  function getReachedEdgeInfo() {
    var bounds = getScrollBounds(),
        reachedEdgeInfo = {
      bottom: false,
      left: false,
      right: false,
      top: false
    };

    if (canScrollHorizontally(bounds)) {
      var edge = getEdgeFromPosition(mutableRef.current.scrollLeft, bounds.maxLeft);

      if (edge) {
        // if edge is null, no need to check which edge is reached.
        if (edge === 'before' && !rtl || edge === 'after' && rtl) {
          reachedEdgeInfo.left = true;
        } else {
          reachedEdgeInfo.right = true;
        }
      }
    }

    if (canScrollVertically(bounds)) {
      var _edge = getEdgeFromPosition(mutableRef.current.scrollTop, bounds.maxTop);

      if (_edge === 'before') {
        reachedEdgeInfo.top = true;
      } else if (_edge === 'after') {
        reachedEdgeInfo.bottom = true;
      }
    }

    return reachedEdgeInfo;
  } // scroll start/stop
  // scrollMode 'translate' [[


  function doScrollStop() {
    mutableRef.current.scrolling = false;
    forwardScrollEvent('onScrollStop', getReachedEdgeInfo());
  } // scrollMode 'translate' ]]


  function start(_ref2) {
    var targetX = _ref2.targetX,
        targetY = _ref2.targetY,
        _ref2$animate = _ref2.animate,
        animate = _ref2$animate === void 0 ? true : _ref2$animate,
        _ref2$duration = _ref2.duration,
        duration = _ref2$duration === void 0 ? animationDuration : _ref2$duration,
        _ref2$overscrollEffec = _ref2.overscrollEffect,
        overscrollEffect = _ref2$overscrollEffec === void 0 ? false : _ref2$overscrollEffec;
    var _mutableRef$current3 = mutableRef.current,
        scrollLeft = _mutableRef$current3.scrollLeft,
        scrollTop = _mutableRef$current3.scrollTop,
        bounds = getScrollBounds(),
        maxLeft = bounds.maxLeft,
        maxTop = bounds.maxTop;
    var updatedAnimationInfo = scrollMode === 'translate' ? {
      sourceX: scrollLeft,
      sourceY: scrollTop,
      targetX: targetX,
      targetY: targetY,
      duration: duration
    } : {
      targetX: targetX,
      targetY: targetY
    }; // bail early when scrolling to the same position

    if ((scrollMode === 'translate' && mutableRef.current.animator.isAnimating() || scrollMode === 'native' && mutableRef.current.scrolling) && mutableRef.current.animationInfo && mutableRef.current.animationInfo.targetX === targetX && mutableRef.current.animationInfo.targetY === targetY) {
      return;
    }

    mutableRef.current.animationInfo = updatedAnimationInfo;

    if (scrollMode === 'translate') {
      mutableRef.current.animator.stop();

      if (!mutableRef.current.scrolling) {
        mutableRef.current.scrolling = true;
        forwardScrollEvent('onScrollStart');
      }

      mutableRef.current.scrollStopJob.stop();
    }

    if (Math.abs(maxLeft - targetX) < epsilon) {
      targetX = maxLeft;
    }

    if (Math.abs(maxTop - targetY) < epsilon) {
      targetY = maxTop;
    }

    if (mutableRef.current.overscrollEnabled && overscrollEffect) {
      if (scrollLeft !== targetX && canScrollHorizontally(bounds)) {
        checkAndApplyOverscrollEffectOnStart('horizontal', getEdgeFromPosition(targetX, maxLeft), targetX);
      }

      if (scrollTop !== targetY && canScrollVertically(bounds)) {
        checkAndApplyOverscrollEffectOnStart('vertical', getEdgeFromPosition(targetY, maxTop), targetY);
      }
    }

    if (scrollMode === 'translate') {
      showScrollbarTrack(bounds);

      if (scrollContentHandle.current && scrollContentHandle.current.setScrollPositionTarget) {
        scrollContentHandle.current.setScrollPositionTarget(targetX, targetY);
      }

      if (animate) {
        mutableRef.current.animator.animate(scrollAnimation(mutableRef.current.animationInfo));
      } else {
        scroll(targetX, targetY);
        stop();
      }
    } else {
      // scrollMode 'native'
      if (animate) {
        scrollContentHandle.current.scrollToPosition(targetX, targetY, 'smooth');
      } else {
        scrollContentHandle.current.scrollToPosition(targetX, targetY, 'instant');
      }

      if (props.start) {
        props.start(animate);
      }
    }
  } // scrollMode 'translate' [[


  function scrollAnimation(animationInfo) {
    return function (curTime) {
      var sourceX = animationInfo.sourceX,
          sourceY = animationInfo.sourceY,
          targetX = animationInfo.targetX,
          targetY = animationInfo.targetY,
          duration = animationInfo.duration,
          bounds = getScrollBounds();

      if (curTime < duration) {
        var toBeContinued = false,
            curTargetX = sourceX,
            curTargetY = sourceY;

        if (canScrollHorizontally(bounds)) {
          curTargetX = mutableRef.current.animator.timingFunction(sourceX, targetX, duration, curTime);

          if (Math.abs(curTargetX - targetX) < epsilon) {
            curTargetX = targetX;
          } else {
            toBeContinued = true;
          }
        }

        if (canScrollVertically(bounds)) {
          curTargetY = mutableRef.current.animator.timingFunction(sourceY, targetY, duration, curTime);

          if (Math.abs(curTargetY - targetY) < epsilon) {
            curTargetY = targetY;
          } else {
            toBeContinued = true;
          }
        }

        scroll(curTargetX, curTargetY);

        if (!toBeContinued) {
          stop();
        }
      } else {
        scroll(targetX, targetY);
        stop();
      }
    };
  }

  function scroll(left, top) {
    if (left !== mutableRef.current.scrollLeft) {
      setScrollLeft(left);
    }

    if (top !== mutableRef.current.scrollTop) {
      setScrollTop(top);
    }

    scrollContentHandle.current.setScrollPosition(mutableRef.current.scrollLeft, mutableRef.current.scrollTop);
    forwardScrollEvent('onScroll');
  } // scrollMode 'translate' ]]


  function stopForTranslate() {
    mutableRef.current.animator.stop();
    mutableRef.current.lastInputType = null;
    mutableRef.current.isScrollAnimationTargetAccumulated = false;
    startHidingScrollbarTrack();

    if (mutableRef.current.overscrollEnabled && !mutableRef.current.isDragging) {
      // not check overscrollEffectOn && overscrollEffectOn for safety
      clearAllOverscrollEffects();
    }

    if (props.stop) {
      props.stop();
    }

    if (mutableRef.current.scrolling) {
      mutableRef.current.scrollStopJob.start();
    }
  }

  function stopForNative() {
    scrollContentHandle.current.scrollToPosition(mutableRef.current.scrollLeft + (rtl ? -0.1 : 0.1), mutableRef.current.scrollTop + 0.1, 'instant');
  }

  function stop() {
    if (scrollMode === 'translate') {
      stopForTranslate();
    } else {
      stopForNative();
    }
  } // scrollTo API


  function getPositionForScrollTo(opt) {
    var bounds = getScrollBounds(),
        canScrollH = canScrollHorizontally(bounds),
        canScrollV = canScrollVertically(bounds);
    var itemPos,
        left = null,
        top = null;

    if (opt instanceof Object) {
      if (opt.position instanceof Object) {
        if (canScrollH) {
          // We need '!=' to check if opt.position.x is null or undefined
          left = opt.position.x != null ? opt.position.x : mutableRef.current.scrollLeft;
        } else {
          left = 0;
        }

        if (canScrollV) {
          // We need '!=' to check if opt.position.y is null or undefined
          top = opt.position.y != null ? opt.position.y : mutableRef.current.scrollTop;
        } else {
          top = 0;
        }
      } else if (typeof opt.align === 'string') {
        if (canScrollH) {
          if (opt.align.includes('left')) {
            left = 0;
          } else if (opt.align.includes('right')) {
            left = bounds.maxLeft;
          }
        }

        if (canScrollV) {
          if (opt.align.includes('top')) {
            top = 0;
          } else if (opt.align.includes('bottom')) {
            top = bounds.maxTop;
          }
        }
      } else {
        if (typeof opt.index === 'number' && typeof scrollContentHandle.current.getItemPosition === 'function') {
          itemPos = scrollContentHandle.current.getItemPosition(opt.index, opt.stickTo, opt.offset);
        } else if (opt.node instanceof Object) {
          if (opt.node.nodeType === 1 && typeof scrollContentHandle.current.getNodePosition === 'function') {
            itemPos = scrollContentHandle.current.getNodePosition(opt.node);
          }
        }

        if (itemPos) {
          if (canScrollH) {
            left = itemPos.left;
          }

          if (canScrollV) {
            top = itemPos.top;
          }
        }
      }
    }

    return {
      left: left,
      top: top
    };
  }

  function scrollTo(opt) {
    if (!mutableRef.current.deferScrollTo) {
      var _getPositionForScroll = getPositionForScrollTo(opt),
          left = _getPositionForScroll.left,
          top = _getPositionForScroll.top;

      var targetX = left !== null ? left : mutableRef.current.scrollLeft;
      var targetY = top !== null ? top : mutableRef.current.scrollTop;

      if (props.scrollTo) {
        props.scrollTo(opt);
      }

      mutableRef.current.scrollToInfo = null;

      if (scrollMode === 'native' && scrollContentHandle.current && scrollContentHandle.current.setScrollToPositionTarget) {
        scrollContentHandle.current.setScrollToPositionTarget(targetX, targetY);
      }

      start({
        targetX: targetX,
        targetY: targetY,
        animate: opt.animate
      });
    } else {
      mutableRef.current.scrollToInfo = opt;
    }
  }

  function canScrollHorizontally(bounds) {
    return (direction === 'horizontal' || direction === 'both') && bounds.scrollWidth > bounds.clientWidth && !isNaN(bounds.scrollWidth);
  }

  function canScrollVertically(bounds) {
    return (direction === 'vertical' || direction === 'both') && bounds.scrollHeight > bounds.clientHeight && !isNaN(bounds.scrollHeight);
  } // scroll bar


  function showScrollbarTrack(bounds) {
    if (isHorizontalScrollbarVisible && canScrollHorizontally(bounds) && horizontalScrollbarHandle.current) {
      horizontalScrollbarHandle.current.showScrollbarTrack();
    }

    if (isVerticalScrollbarVisible && canScrollVertically(bounds) && verticalScrollbarHandle.current) {
      verticalScrollbarHandle.current.showScrollbarTrack();
    }
  }

  function updateScrollbarTrack(scrollbarRef, bounds) {
    scrollbarRef.current.update(_objectSpread(_objectSpread({}, bounds), {}, {
      scrollLeft: mutableRef.current.scrollLeft,
      scrollTop: mutableRef.current.scrollTop
    }));
  }

  function startHidingScrollbarTrack() {
    if (isHorizontalScrollbarVisible && horizontalScrollbarHandle.current) {
      horizontalScrollbarHandle.current.startHidingScrollbarTrack();
    }

    if (isVerticalScrollbarVisible && verticalScrollbarHandle.current) {
      verticalScrollbarHandle.current.startHidingScrollbarTrack();
    }
  }

  function updateScrollbars() {
    var bounds = getScrollBounds(),
        canScrollH = canScrollHorizontally(bounds),
        canScrollV = canScrollVertically(bounds),
        curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollH : horizontalScrollbar === 'visible',
        curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollV : verticalScrollbar === 'visible'; // determine if we should hide or show any scrollbars

    var isVisibilityChanged = isHorizontalScrollbarVisible !== curHorizontalScrollbarVisible || isVerticalScrollbarVisible !== curVerticalScrollbarVisible;

    if (isVisibilityChanged) {
      // one or both scrollbars have changed visibility
      setIsHorizontalScrollbarVisible(curHorizontalScrollbarVisible);
      setIsVerticalScrollbarVisible(curVerticalScrollbarVisible);
    } else {
      mutableRef.current.deferScrollTo = false;
      updateScrollbarTrackSize();
    }
  }

  function updateScrollbarTrackSize() {
    var bounds = getScrollBounds(),
        canScrollH = canScrollHorizontally(bounds),
        canScrollV = canScrollVertically(bounds),
        curHorizontalScrollbarVisible = horizontalScrollbar === 'auto' ? canScrollH : horizontalScrollbar === 'visible',
        curVerticalScrollbarVisible = verticalScrollbar === 'auto' ? canScrollV : verticalScrollbar === 'visible';

    if (curHorizontalScrollbarVisible || curVerticalScrollbarVisible) {
      // no visibility change but need to notify whichever scrollbars are visible of the
      // updated bounds and scroll position
      var updatedBounds = _objectSpread(_objectSpread({}, bounds), {}, {
        scrollLeft: mutableRef.current.scrollLeft,
        scrollTop: mutableRef.current.scrollTop
      });

      if (curHorizontalScrollbarVisible && horizontalScrollbarHandle.current) {
        horizontalScrollbarHandle.current.update(updatedBounds);
      }

      if (curVerticalScrollbarVisible && verticalScrollbarHandle.current) {
        verticalScrollbarHandle.current.update(updatedBounds);
      }

      return true;
    }

    return false;
  } // ref


  function getScrollBounds() {
    if (scrollContentHandle.current && typeof scrollContentHandle.current.getScrollBounds === 'function') {
      return scrollContentHandle.current.getScrollBounds();
    }
  }

  function getMoreInfo() {
    if (scrollContentHandle.current && typeof scrollContentHandle.current.getMoreInfo === 'function') {
      return scrollContentHandle.current.getMoreInfo();
    }
  } // FIXME setting event handlers directly to work on the V8 snapshot.


  function addEventListeners() {
    (0, _utilEvent["default"])('wheel').addEventListener(scrollContainerRef, onWheel);
    (0, _utilEvent["default"])('keydown').addEventListener(scrollContainerRef, onKeyDown);
    (0, _utilEvent["default"])('mousedown').addEventListener(scrollContainerRef, onMouseDown); // scrollMode 'native' [[

    if (scrollMode === 'native' && scrollContentRef.current) {
      (0, _utilEvent["default"])('scroll').addEventListener(scrollContentRef, onScroll, {
        passive: true
      });
    } // scrollMode 'native' ]]


    if (props.addEventListeners) {
      props.addEventListeners(scrollContentRef);
    }

    if (window) {
      (0, _utilEvent["default"])('resize').addEventListener(window, handleResizeWindow);
    }
  } // FIXME setting event handlers directly to work on the V8 snapshot.


  function removeEventListeners() {
    (0, _utilEvent["default"])('wheel').removeEventListener(scrollContainerRef, onWheel);
    (0, _utilEvent["default"])('keydown').removeEventListener(scrollContainerRef, onKeyDown);
    (0, _utilEvent["default"])('mousedown').removeEventListener(scrollContainerRef, onMouseDown); // scrollMode 'native' [[

    (0, _utilEvent["default"])('scroll').removeEventListener(scrollContentRef, onScroll, {
      passive: true
    }); // scrollMode 'native' ]]

    if (props.removeEventListeners) {
      props.removeEventListeners(scrollContentRef);
    }

    (0, _utilEvent["default"])('resize').removeEventListener(window, handleResizeWindow);
  } // render
  // scrollMode 'translate' [[


  function handleScroll() {
    // Prevent scroll by focus.
    // VirtualList and VirtualGridList DO NOT receive `onscroll` event.
    // Only Scroller could get `onscroll` event.
    if (!mutableRef.current.animator.isAnimating() && scrollContentHandle.current && scrollContentRef.current && scrollContentHandle.current.getRtlPositionX && !mutableRef.current.isDragging) {
      // For Scroller
      scrollContentRef.current.scrollTop = mutableRef.current.scrollTop;
      scrollContentRef.current.scrollLeft = scrollContentHandle.current.getRtlPositionX(mutableRef.current.scrollLeft);
    }
  } // scrollMode 'translate' ]]


  function scrollContainerContainsDangerously(target) {
    return _utilDOM["default"].containsDangerously(scrollContainerRef, target);
  }

  assignProperties('scrollContainerProps', _objectSpread(_objectSpread({}, rest), {}, {
    className: [scrollClasses]
  }));
  assignProperties('scrollInnerContainerProps', {
    className: [_useScrollModule["default"].scrollInnerContainer]
  });
  assignProperties('scrollContentWrapperProps', _objectSpread({
    className: scrollMode === 'translate' ? [_useScrollModule["default"].scrollContentWrapper] : [_useScrollModule["default"].scrollContentWrapper, _useScrollModule["default"].scrollContentWrapperNative]
  }, !noScrollByDrag && {
    flickConfig: flickConfig,
    onDrag: onDrag,
    onDragEnd: onDragEnd,
    onDragStart: onDragStart,
    onFlick: onFlick,
    onTouchStart: scrollMode === 'native' ? onTouchStart : null // scrollMode 'native'

  }));
  var scrollContentProps = props.itemRenderer ? // If the child component is a VirtualList
  {
    childProps: childProps,
    clientSize: clientSize,
    dataSize: dataSize,
    itemRenderer: itemRenderer,
    itemSize: itemSize,
    itemSizes: itemSizes,
    overhang: overhang,
    pageScroll: pageScroll,
    spacing: spacing,
    wrap: wrap
  } : {
    children: children
  };
  assignProperties('scrollContentProps', _objectSpread(_objectSpread({}, scrollContentProps), {}, {
    cbScrollTo: scrollTo,
    className: [_useScrollModule["default"].scrollFill],
    direction: direction,

    get isHorizontalScrollbarVisible() {
      return isHorizontalScrollbarVisible;
    },

    get isVerticalScrollbarVisible() {
      return isVerticalScrollbarVisible;
    },

    onScroll: scrollMode === 'translate' ? handleScroll : null,
    role: role,
    rtl: rtl,
    scrollContainerContainsDangerously: scrollContainerContainsDangerously,
    scrollMode: scrollMode
  }));
  assignProperties('verticalScrollbarProps', {
    clientSize: clientSize,
    disabled: !isVerticalScrollbarVisible,
    rtl: rtl,
    vertical: true
  });
  assignProperties('horizontalScrollbarProps', {
    clientSize: clientSize,
    corner: isVerticalScrollbarVisible,
    disabled: !isHorizontalScrollbarVisible,
    rtl: rtl,
    vertical: false
  });
  assignProperties('resizeContextProps', {
    value: mutableRef.current.resizeRegistry.register
  });
  mutableRef.current.deferScrollTo = true;
  mutableRef.current.prevState = {
    isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,
    isVerticalScrollbarVisible: isVerticalScrollbarVisible
  };
  return {
    isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,
    isVerticalScrollbarVisible: isVerticalScrollbarVisible,
    scrollContentWrapper: noScrollByDrag ? 'div' : TouchableDiv,
    scrollObserver: {
      addObserverOnScroll: addObserverOnScroll,
      removeObserverOnScroll: removeObserverOnScroll
    }
  };
};

exports.useScrollBase = useScrollBase;

var assignPropertiesOf = function assignPropertiesOf(instance) {
  return function (name, properties) {
    if (!instance[name]) {
      instance[name] = {};
    }

    if (typeof properties === 'object') {
      for (var property in properties) {
        if (property === 'className') {
          process.env.NODE_ENV !== "production" ? (0, _warning["default"])(Array.isArray(properties.className), 'Unsupported other types for `className` prop except Array') : void 0;
          instance[name].className = (0, _classnames["default"])(instance[name].className, properties.className);
        } else {
          process.env.NODE_ENV !== "production" ? (0, _warning["default"])(!instance[name][property], 'Unsupported to push value in the same ' + property + ' prop.') : void 0; // Override the previous value.

          instance[name][property] = properties[property];
        }
      }
    }
  };
};

exports.assignPropertiesOf = assignPropertiesOf;

var useScroll = function useScroll(props) {
  // Mutable value
  var scrollContainerRef = (0, _react.useRef)({});
  var scrollContentHandle = (0, _react.useRef)({});
  var scrollContentRef = (0, _react.useRef)({});
  var itemRefs = (0, _react.useRef)([]);
  var horizontalScrollbarHandle = (0, _react.useRef)({});
  var verticalScrollbarHandle = (0, _react.useRef)({}); // Hooks

  var collectionOfProperties = {},
      assignProperties = assignPropertiesOf(collectionOfProperties);

  var _useScrollBase = useScrollBase(_objectSpread(_objectSpread({}, props), {}, {
    assignProperties: assignProperties,
    horizontalScrollbarHandle: horizontalScrollbarHandle,
    scrollContainerRef: scrollContainerRef,
    scrollContentHandle: scrollContentHandle,
    scrollContentRef: scrollContentRef,
    verticalScrollbarHandle: verticalScrollbarHandle
  })),
      scrollContentWrapper = _useScrollBase.scrollContentWrapper,
      isHorizontalScrollbarVisible = _useScrollBase.isHorizontalScrollbarVisible,
      isVerticalScrollbarVisible = _useScrollBase.isVerticalScrollbarVisible;

  assignProperties('scrollContainerProps', {
    ref: scrollContainerRef
  });
  assignProperties('scrollContentProps', _objectSpread(_objectSpread({}, props.itemRenderer ? {
    itemRefs: itemRefs
  } : {}), {}, {
    scrollContentRef: scrollContentRef
  }));
  assignProperties('verticalScrollbarProps', {
    scrollbarHandle: verticalScrollbarHandle
  });
  assignProperties('horizontalScrollbarProps', {
    scrollbarHandle: horizontalScrollbarHandle
  }); // Return

  return _objectSpread(_objectSpread({}, collectionOfProperties), {}, {
    scrollContentWrapper: scrollContentWrapper,
    scrollContentHandle: scrollContentHandle,
    isHorizontalScrollbarVisible: isHorizontalScrollbarVisible,
    isVerticalScrollbarVisible: isVerticalScrollbarVisible
  });
};

exports.useScroll = useScroll;
var _default = useScroll;
exports["default"] = _default;